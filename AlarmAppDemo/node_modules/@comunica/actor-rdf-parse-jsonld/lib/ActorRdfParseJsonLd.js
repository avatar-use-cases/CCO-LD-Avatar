"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bus_rdf_parse_1 = require("@comunica/bus-rdf-parse");
const data_model_1 = require("@rdfjs/data-model");
const rdf_terms_1 = require("rdf-terms");
const stream_1 = require("stream");
/**
 * A JSON-LD RDF Parse actor that listens on the 'rdf-parse' bus.
 *
 * It is able to parse JSON-LD-based RDF serializations and announce the presence of them by media type.
 */
class ActorRdfParseJsonLd extends bus_rdf_parse_1.ActorRdfParseFixedMediaTypes {
    constructor(args) {
        super(args);
        this.jsonLd = require('jsonld')();
    }
    static mapTerm(term) {
        switch (term.termType) {
            case 'NamedNode':
                return data_model_1.namedNode(term.value);
            case 'BlankNode':
                return data_model_1.blankNode(term.value.substr(2)); // Remove the '_:' prefix.
            case 'Literal':
                return data_model_1.literal(term.value, term.language || term.datatype);
            /*case 'Variable':
              return variable(term.value);*/ // Variables can not occur in JSON-LD bodies
            case 'DefaultGraph':
                return data_model_1.defaultGraph();
        }
    }
    async runHandle(action, mediaType, context) {
        const quads = new stream_1.Readable({ objectMode: true });
        let initialized = false;
        quads._read = async () => {
            if (!initialized) {
                initialized = true;
                const jsonString = await require('stream-to-string')(action.input);
                const quadsArray = await this.jsonLd.toRDF(JSON.parse(jsonString), { base: action.baseIRI });
                for (const quad of quadsArray) {
                    quads.push(rdf_terms_1.mapTerms(quad, ActorRdfParseJsonLd.mapTerm));
                }
                quads.push(null);
            }
        };
        return { quads };
    }
}
exports.ActorRdfParseJsonLd = ActorRdfParseJsonLd;
//# sourceMappingURL=ActorRdfParseJsonLd.js.map