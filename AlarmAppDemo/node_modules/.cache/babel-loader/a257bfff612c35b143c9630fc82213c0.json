{"ast":null,"code":"// **N3Lexer** tokenizes N3 documents.\nvar fromCharCode = String.fromCharCode;\nvar immediately = typeof setImmediate === 'function' ? setImmediate : function setImmediate(func) {\n  setTimeout(func, 0);\n}; // Regular expression and replacement string to escape N3 strings.\n// Note how we catch invalid unicode sequences separately (they will trigger an error).\n\nvar escapeSequence = /\\\\u([a-fA-F0-9]{4})|\\\\U([a-fA-F0-9]{8})|\\\\[uU]|\\\\(.)/g;\nvar escapeReplacements = {\n  '\\\\': '\\\\',\n  \"'\": \"'\",\n  '\"': '\"',\n  'n': '\\n',\n  'r': '\\r',\n  't': '\\t',\n  'f': '\\f',\n  'b': '\\b',\n  '_': '_',\n  '~': '~',\n  '.': '.',\n  '-': '-',\n  '!': '!',\n  '$': '$',\n  '&': '&',\n  '(': '(',\n  ')': ')',\n  '*': '*',\n  '+': '+',\n  ',': ',',\n  ';': ';',\n  '=': '=',\n  '/': '/',\n  '?': '?',\n  '#': '#',\n  '@': '@',\n  '%': '%'\n};\nvar illegalIriChars = /[\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]/; // ## Constructor\n\nfunction N3Lexer(options) {\n  if (!(this instanceof N3Lexer)) return new N3Lexer(options); // In line mode (N-Triples or N-Quads), only simple features may be parsed\n\n  if (options && options.lineMode) {\n    // Don't tokenize special literals\n    this._tripleQuotedString = this._number = this._boolean = /$0^/; // Swap the tokenize method for a restricted version\n\n    var self = this;\n    this._tokenize = this.tokenize;\n\n    this.tokenize = function (input, callback) {\n      this._tokenize(input, function (error, token) {\n        if (!error && /^(?:IRI|prefixed|literal|langcode|type|\\.|eof)$/.test(token.type)) callback && callback(error, token);else callback && callback(error || self._syntaxError(token.type, callback = null));\n      });\n    };\n  }\n}\n\nN3Lexer.prototype = {\n  // ## Regular expressions\n  // It's slightly faster to have these as properties than as in-scope variables.\n  _iri: /^<((?:[^>\\\\]|\\\\[uU])+)>/,\n  // IRI with escape sequences; needs sanity check after unescaping\n  _unescapedIri: /^<([^\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]*)>/,\n  // IRI without escape sequences; no unescaping\n  _unescapedString: /^\"[^\"\\\\]+\"(?=[^\"\\\\])/,\n  // non-empty string without escape sequences\n  _singleQuotedString: /^\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"(?=[^\"\\\\])|^'[^'\\\\]*(?:\\\\.[^'\\\\]*)*'(?=[^'\\\\])/,\n  _tripleQuotedString: /^\"\"(\"[^\"\\\\]*(?:(?:\\\\.|\"(?!\"\"))[^\"\\\\]*)*\")\"\"|^''('[^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*')''/,\n  _langcode: /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\\-])/i,\n  _prefix: /^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:(?=[#\\s<])/,\n  _prefixed: /^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:((?:(?:[0-:A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])(?:(?:[\\.\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])*(?:[\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~]))?)?)(?=\\.?[,;\\s#()\\[\\]\\{\\}\"'<])/,\n  _blank: /^_:((?:[0-9A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)(?=\\.?[,;:\\s#()\\[\\]\\{\\}\"'<])/,\n  _number: /^[\\-+]?(?:\\d+\\.?\\d*([eE](?:[\\-\\+])?\\d+)|\\d*\\.?\\d+)(?=[.,;:\\s#()\\[\\]\\{\\}\"'<])/,\n  _boolean: /^(?:true|false)(?=[.,;:\\s#()\\[\\]\\{\\}\"'<])/,\n  _keyword: /^@[a-z]+(?=[\\s#<:])/,\n  _sparqlKeyword: /^(?:PREFIX|BASE|GRAPH)(?=[\\s#<:])/i,\n  _shortPredicates: /^a(?=\\s+|<)/,\n  _newline: /^[ \\t]*(?:#[^\\n\\r]*)?(?:\\r\\n|\\n|\\r)[ \\t]*/,\n  _whitespace: /^[ \\t]+/,\n  _endOfFile: /^(?:#[^\\n\\r]*)?$/,\n  // ## Private methods\n  // ### `_tokenizeToEnd` tokenizes as for as possible, emitting tokens through the callback.\n  _tokenizeToEnd: function _tokenizeToEnd(callback, inputFinished) {\n    // Continue parsing as far as possible; the loop will return eventually.\n    var input = this._input;\n\n    while (true) {\n      // Count and skip whitespace lines.\n      var whiteSpaceMatch;\n\n      while (whiteSpaceMatch = this._newline.exec(input)) {\n        input = input.substr(whiteSpaceMatch[0].length, input.length), this._line++;\n      } // Skip whitespace on current line.\n\n\n      if (whiteSpaceMatch = this._whitespace.exec(input)) input = input.substr(whiteSpaceMatch[0].length, input.length); // Stop for now if we're at the end.\n\n      if (this._endOfFile.test(input)) {\n        // If the input is finished, emit EOF.\n        if (inputFinished) callback(input = null, {\n          line: this._line,\n          type: 'eof',\n          value: '',\n          prefix: ''\n        });\n        return this._input = input;\n      } // Look for specific token types based on the first character.\n\n\n      var line = this._line,\n          type = '',\n          value = '',\n          prefix = '',\n          firstChar = input[0],\n          match = null,\n          matchLength = 0,\n          unescaped,\n          inconclusive = false;\n\n      switch (firstChar) {\n        case '^':\n          // Try to match a type.\n          if (input.length === 1) break;else if (input[1] !== '^') return reportSyntaxError(this);\n          this._prevTokenType = '^'; // Move to type IRI or prefixed name.\n\n          input = input.substr(2);\n\n          if (input[0] !== '<') {\n            inconclusive = true;\n            break;\n          }\n\n        // Fall through in case the type is an IRI.\n\n        case '<':\n          // Try to find a full IRI without escape sequences.\n          if (match = this._unescapedIri.exec(input)) type = 'IRI', value = match[1]; // Try to find a full IRI with escape sequences.\n          else if (match = this._iri.exec(input)) {\n              unescaped = this._unescape(match[1]);\n              if (unescaped === null || illegalIriChars.test(unescaped)) return reportSyntaxError(this);\n              type = 'IRI', value = unescaped;\n            }\n          break;\n\n        case '_':\n          // Try to find a blank node. Since it can contain (but not end with) a dot,\n          // we always need a non-dot character before deciding it is a prefixed name.\n          // Therefore, try inserting a space if we're at the end of the input.\n          if ((match = this._blank.exec(input)) || inputFinished && (match = this._blank.exec(input + ' '))) type = 'prefixed', prefix = '_', value = match[1];\n          break;\n\n        case '\"':\n        case \"'\":\n          // Try to find a non-empty double-quoted literal without escape sequences.\n          if (match = this._unescapedString.exec(input)) type = 'literal', value = match[0]; // Try to find any other literal wrapped in a pair of single or double quotes.\n          else if (match = this._singleQuotedString.exec(input)) {\n              unescaped = this._unescape(match[0]);\n              if (unescaped === null) return reportSyntaxError(this);\n              type = 'literal', value = unescaped.replace(/^'|'$/g, '\"');\n            } // Try to find a literal wrapped in three pairs of single or double quotes.\n            else if (match = this._tripleQuotedString.exec(input)) {\n                unescaped = match[1] || match[2]; // Count the newlines and advance line counter.\n\n                this._line += unescaped.split(/\\r\\n|\\r|\\n/).length - 1;\n                unescaped = this._unescape(unescaped);\n                if (unescaped === null) return reportSyntaxError(this);\n                type = 'literal', value = unescaped.replace(/^'|'$/g, '\"');\n              }\n          break;\n\n        case '@':\n          // Try to find a language code.\n          if (this._prevTokenType === 'literal' && (match = this._langcode.exec(input))) type = 'langcode', value = match[1]; // Try to find a keyword.\n          else if (match = this._keyword.exec(input)) type = match[0];\n          break;\n\n        case '.':\n          // Try to find a dot as punctuation.\n          if (input.length === 1 ? inputFinished : input[1] < '0' || input[1] > '9') {\n            type = '.';\n            matchLength = 1;\n            break;\n          }\n\n        // Fall through to numerical case (could be a decimal dot).\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n        case '+':\n        case '-':\n          // Try to find a number.\n          if (match = this._number.exec(input)) {\n            type = 'literal';\n            value = '\"' + match[0] + '\"^^http://www.w3.org/2001/XMLSchema#' + (match[1] ? 'double' : /^[+\\-]?\\d+$/.test(match[0]) ? 'integer' : 'decimal');\n          }\n\n          break;\n\n        case 'B':\n        case 'b':\n        case 'p':\n        case 'P':\n        case 'G':\n        case 'g':\n          // Try to find a SPARQL-style keyword.\n          if (match = this._sparqlKeyword.exec(input)) type = match[0].toUpperCase();else inconclusive = true;\n          break;\n\n        case 'f':\n        case 't':\n          // Try to match a boolean.\n          if (match = this._boolean.exec(input)) type = 'literal', value = '\"' + match[0] + '\"^^http://www.w3.org/2001/XMLSchema#boolean';else inconclusive = true;\n          break;\n\n        case 'a':\n          // Try to find an abbreviated predicate.\n          if (match = this._shortPredicates.exec(input)) type = 'abbreviation', value = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type';else inconclusive = true;\n          break;\n\n        case ',':\n        case ';':\n        case '[':\n        case ']':\n        case '(':\n        case ')':\n        case '{':\n        case '}':\n          // The next token is punctuation\n          matchLength = 1;\n          type = firstChar;\n          break;\n\n        default:\n          inconclusive = true;\n      } // Some first characters do not allow an immediate decision, so inspect more.\n\n\n      if (inconclusive) {\n        // Try to find a prefix.\n        if ((this._prevTokenType === '@prefix' || this._prevTokenType === 'PREFIX') && (match = this._prefix.exec(input))) type = 'prefix', value = match[1] || ''; // Try to find a prefixed name. Since it can contain (but not end with) a dot,\n        // we always need a non-dot character before deciding it is a prefixed name.\n        // Therefore, try inserting a space if we're at the end of the input.\n        else if ((match = this._prefixed.exec(input)) || inputFinished && (match = this._prefixed.exec(input + ' '))) type = 'prefixed', prefix = match[1] || '', value = this._unescape(match[2]);\n      } // A type token is special: it can only be emitted after an IRI or prefixed name is read.\n\n\n      if (this._prevTokenType === '^') type = type === 'IRI' || type === 'prefixed' ? 'type' : ''; // What if nothing of the above was found?\n\n      if (!type) {\n        // We could be in streaming mode, and then we just wait for more input to arrive.\n        // Otherwise, a syntax error has occurred in the input.\n        // One exception: error on an unaccounted linebreak (= not inside a triple-quoted literal).\n        if (inputFinished || !/^'''|^\"\"\"/.test(input) && /\\n|\\r/.test(input)) return reportSyntaxError(this);else return this._input = input;\n      } // Emit the parsed token.\n\n\n      callback(null, {\n        line: line,\n        type: type,\n        value: value,\n        prefix: prefix\n      });\n      this._prevTokenType = type; // Advance to next part to tokenize.\n\n      input = input.substr(matchLength || match[0].length, input.length);\n    } // Signals the syntax error through the callback\n\n\n    function reportSyntaxError(self) {\n      callback(self._syntaxError(/^\\S*/.exec(input)[0]));\n    }\n  },\n  // ### `_unescape` replaces N3 escape codes by their corresponding characters.\n  _unescape: function _unescape(item) {\n    try {\n      return item.replace(escapeSequence, function (sequence, unicode4, unicode8, escapedChar) {\n        var charCode;\n\n        if (unicode4) {\n          charCode = parseInt(unicode4, 16);\n          if (isNaN(charCode)) throw new Error(); // can never happen (regex), but helps performance\n\n          return fromCharCode(charCode);\n        } else if (unicode8) {\n          charCode = parseInt(unicode8, 16);\n          if (isNaN(charCode)) throw new Error(); // can never happen (regex), but helps performance\n\n          if (charCode <= 0xFFFF) return fromCharCode(charCode);\n          return fromCharCode(0xD800 + (charCode -= 0x10000) / 0x400, 0xDC00 + (charCode & 0x3FF));\n        } else {\n          var replacement = escapeReplacements[escapedChar];\n          if (!replacement) throw new Error();\n          return replacement;\n        }\n      });\n    } catch (error) {\n      return null;\n    }\n  },\n  // ### `_syntaxError` creates a syntax error for the given issue\n  _syntaxError: function _syntaxError(issue) {\n    this._input = null;\n    return new Error('Syntax error: unexpected \"' + issue + '\" on line ' + this._line + '.');\n  },\n  // ## Public methods\n  // ### `tokenize` starts the transformation of an N3 document into an array of tokens.\n  // The input can be a string or a stream.\n  tokenize: function tokenize(input, callback) {\n    var self = this;\n    this._line = 1; // If the input is a string, continuously emit tokens through the callback until the end.\n\n    if (typeof input === 'string') {\n      this._input = input;\n      immediately(function () {\n        self._tokenizeToEnd(callback, true);\n      });\n    } // Otherwise, the input will be streamed.\n    else {\n        this._input = ''; // If no input was given, it will be streamed through `addChunk` and ended with `end`\n\n        if (!input || typeof input === 'function') {\n          this.addChunk = addChunk;\n          this.end = end;\n          if (!callback) callback = input;\n        } // Otherwise, the input itself must be a stream\n        else {\n            if (typeof input.setEncoding === 'function') input.setEncoding('utf8');\n            input.on('data', addChunk);\n            input.on('end', end);\n          }\n      } // Adds the data chunk to the buffer and parses as far as possible\n\n\n    function addChunk(data) {\n      if (self._input !== null) {\n        self._input += data;\n\n        self._tokenizeToEnd(callback, false);\n      }\n    } // Parses until the end\n\n\n    function end() {\n      if (self._input !== null) self._tokenizeToEnd(callback, true);\n    }\n  }\n}; // ## Exports\n// Export the `N3Lexer` class as a whole.\n\nmodule.exports = N3Lexer;","map":null,"metadata":{},"sourceType":"script"}