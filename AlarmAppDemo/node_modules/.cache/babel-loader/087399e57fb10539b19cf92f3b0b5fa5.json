{"ast":null,"code":"// **N3Store** objects store N3 triples by graph in memory.\nvar expandPrefixedName = require('./N3Util').expandPrefixedName; // ## Constructor\n\n\nfunction N3Store(triples, options) {\n  if (!(this instanceof N3Store)) return new N3Store(triples, options); // The number of triples is initially zero.\n\n  this._size = 0; // `_graphs` contains subject, predicate, and object indexes per graph.\n\n  this._graphs = Object.create(null); // `_entities` maps entities such as `http://xmlns.com/foaf/0.1/name` to numbers.\n  // This saves memory, since only the numbers have to be stored in `_graphs`.\n\n  this._entities = Object.create(null);\n  this._entities['><'] = 0; // Dummy entry, so the first actual key is non-zero\n\n  this._entityCount = 0; // `_blankNodeIndex` is the index of the last created blank node that was automatically named\n\n  this._blankNodeIndex = 0; // Shift parameters if `triples` is not given\n\n  if (!options && triples && !triples[0]) options = triples, triples = null; // Add triples and prefixes if passed\n\n  this._prefixes = Object.create(null);\n  if (options && options.prefixes) this.addPrefixes(options.prefixes);\n  if (triples) this.addTriples(triples);\n}\n\nN3Store.prototype = {\n  // ## Public properties\n  // ### `size` returns the number of triples in the store.\n  get size() {\n    // Return the triple count if if was cached.\n    var size = this._size;\n    if (size !== null) return size; // Calculate the number of triples by counting to the deepest level.\n\n    var graphs = this._graphs,\n        subjects,\n        subject;\n\n    for (var graphKey in graphs) {\n      for (var subjectKey in subjects = graphs[graphKey].subjects) {\n        for (var predicateKey in subject = subjects[subjectKey]) {\n          size += Object.keys(subject[predicateKey]).length;\n        }\n      }\n    }\n\n    return this._size = size;\n  },\n\n  // ## Private methods\n  // ### `_addToIndex` adds a triple to a three-layered index.\n  _addToIndex: function _addToIndex(index0, key0, key1, key2) {\n    // Create layers as necessary.\n    var index1 = index0[key0] || (index0[key0] = {});\n    var index2 = index1[key1] || (index1[key1] = {}); // Setting the key to _any_ value signalizes the presence of the triple.\n\n    index2[key2] = null;\n  },\n  // ### `_removeFromIndex` removes a triple from a three-layered index.\n  _removeFromIndex: function _removeFromIndex(index0, key0, key1, key2) {\n    // Remove the triple from the index.\n    var index1 = index0[key0],\n        index2 = index1[key1],\n        key;\n    delete index2[key2]; // Remove intermediary index layers if they are empty.\n\n    for (key in index2) {\n      return;\n    }\n\n    delete index1[key1];\n\n    for (key in index1) {\n      return;\n    }\n\n    delete index0[key0];\n  },\n  // ### `_findInIndex` finds a set of triples in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be `null`, which is interpreted as a wildcard.\n  // `name0`, `name1`, and `name2` are the names of the keys at each level,\n  // used when reconstructing the resulting triple\n  // (for instance: _subject_, _predicate_, and _object_).\n  // Finally, `graph` will be the graph of the created triples.\n  _findInIndex: function _findInIndex(index0, key0, key1, key2, name0, name1, name2, graph) {\n    var results = [],\n        entityKeys = Object.keys(this._entities),\n        tmp,\n        index1,\n        index2; // If a key is specified, use only that part of index 0.\n\n    if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];\n\n    for (var value0 in index0) {\n      var entity0 = entityKeys[value0];\n\n      if (index1 = index0[value0]) {\n        // If a key is specified, use only that part of index 1.\n        if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];\n\n        for (var value1 in index1) {\n          var entity1 = entityKeys[value1];\n\n          if (index2 = index1[value1]) {\n            // If a key is specified, use only that part of index 2, if it exists.\n            var values = key2 ? key2 in index2 ? [key2] : [] : Object.keys(index2); // Create triples for all items found in index 2.\n\n            for (var l = values.length - 1; l >= 0; l--) {\n              var result = {\n                subject: '',\n                predicate: '',\n                object: '',\n                graph: graph\n              };\n              result[name0] = entity0;\n              result[name1] = entity1;\n              result[name2] = entityKeys[values[l]];\n              results.push(result);\n            }\n          }\n        }\n      }\n    }\n\n    return results;\n  },\n  // ### `_countInIndex` counts matching triples in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be `null`, which is interpreted as a wildcard.\n  _countInIndex: function _countInIndex(index0, key0, key1, key2) {\n    var count = 0,\n        tmp,\n        index1,\n        index2; // If a key is specified, count only that part of index 0.\n\n    if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];\n\n    for (var value0 in index0) {\n      if (index1 = index0[value0]) {\n        // If a key is specified, count only that part of index 1.\n        if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];\n\n        for (var value1 in index1) {\n          if (index2 = index1[value1]) {\n            // If a key is specified, count the triple if it exists.\n            if (key2) key2 in index2 && count++; // Otherwise, count all triples.\n            else count += Object.keys(index2).length;\n          }\n        }\n      }\n    }\n\n    return count;\n  },\n  // ## Public methods\n  // ### `addTriple` adds a new N3 triple to the store.\n  addTriple: function addTriple(subject, predicate, object, graph) {\n    // Shift arguments if a triple object is given instead of components\n    if (!predicate) graph = subject.graph, object = subject.object, predicate = subject.predicate, subject = subject.subject; // Find the graph that will contain the triple.\n\n    graph = graph || '';\n    var graphItem = this._graphs[graph]; // Create the graph if it doesn't exist yet.\n\n    if (!graphItem) {\n      graphItem = this._graphs[graph] = {\n        subjects: {},\n        predicates: {},\n        objects: {}\n      }; // Freezing a graph helps subsequent `add` performance,\n      // and properties will never be modified anyway.\n\n      Object.freeze(graphItem);\n    } // Since entities can often be long IRIs, we avoid storing them in every index.\n    // Instead, we have a separate index that maps entities to numbers,\n    // which are then used as keys in the other indexes.\n\n\n    var entities = this._entities;\n    subject = entities[subject] || (entities[subject] = ++this._entityCount);\n    predicate = entities[predicate] || (entities[predicate] = ++this._entityCount);\n    object = entities[object] || (entities[object] = ++this._entityCount);\n\n    this._addToIndex(graphItem.subjects, subject, predicate, object);\n\n    this._addToIndex(graphItem.predicates, predicate, object, subject);\n\n    this._addToIndex(graphItem.objects, object, subject, predicate); // The cached triple count is now invalid.\n\n\n    this._size = null;\n  },\n  // ### `addTriples` adds multiple N3 triples to the store.\n  addTriples: function addTriples(triples) {\n    for (var i = triples.length - 1; i >= 0; i--) {\n      this.addTriple(triples[i]);\n    }\n  },\n  // ### `addPrefix` adds support for querying with the given prefix\n  addPrefix: function addPrefix(prefix, iri) {\n    this._prefixes[prefix] = iri;\n  },\n  // ### `addPrefixes` adds support for querying with the given prefixes\n  addPrefixes: function addPrefixes(prefixes) {\n    for (var prefix in prefixes) {\n      this.addPrefix(prefix, prefixes[prefix]);\n    }\n  },\n  // ### `removeTriple` removes an N3 triple from the store if it exists.\n  removeTriple: function removeTriple(subject, predicate, object, graph) {\n    // Shift arguments if a triple object is given instead of components.\n    if (!predicate) graph = subject.graph, object = subject.object, predicate = subject.predicate, subject = subject.subject;\n    graph = graph || ''; // Find internal identifiers for all components.\n\n    var graphItem,\n        entities = this._entities,\n        graphs = this._graphs;\n    if (!(subject = entities[subject])) return;\n    if (!(predicate = entities[predicate])) return;\n    if (!(object = entities[object])) return;\n    if (!(graphItem = graphs[graph])) return; // Verify that the triple exists.\n\n    var subjects, predicates;\n    if (!(subjects = graphItem.subjects[subject])) return;\n    if (!(predicates = subjects[predicate])) return;\n    if (!(object in predicates)) return; // Remove it from all indexes.\n\n    this._removeFromIndex(graphItem.subjects, subject, predicate, object);\n\n    this._removeFromIndex(graphItem.predicates, predicate, object, subject);\n\n    this._removeFromIndex(graphItem.objects, object, subject, predicate);\n\n    if (this._size !== null) this._size--; // Remove the graph if it is empty.\n\n    for (subject in graphItem.subjects) {\n      return;\n    }\n\n    delete graphs[graph];\n  },\n  // ### `removeTriples` removes multiple N3 triples from the store.\n  removeTriples: function removeTriples(triples) {\n    for (var i = triples.length - 1; i >= 0; i--) {\n      this.removeTriple(triples[i]);\n    }\n  },\n  // ### `find` finds a set of triples matching a pattern, expanding prefixes as necessary.\n  // Setting `subject`, `predicate`, or `object` to `null` means an _anything_ wildcard.\n  // Setting `graph` to `null` means the default graph.\n  find: function find(subject, predicate, object, graph) {\n    var prefixes = this._prefixes;\n    return this.findByIRI(expandPrefixedName(subject, prefixes), expandPrefixedName(predicate, prefixes), expandPrefixedName(object, prefixes), expandPrefixedName(graph, prefixes));\n  },\n  // ### `findByIRI` finds a set of triples matching a pattern.\n  // Setting `subject`, `predicate`, or `object` to a falsy value means an _anything_ wildcard.\n  // Setting `graph` to a falsy value means the default graph.\n  findByIRI: function findByIRI(subject, predicate, object, graph) {\n    graph = graph || '';\n    var graphItem = this._graphs[graph],\n        entities = this._entities; // If the specified graph contain no triples, there are no results.\n\n    if (!graphItem) return []; // Translate IRIs to internal index keys.\n    // Optimization: if the entity doesn't exist, no triples with it exist.\n\n    if (subject && !(subject = entities[subject])) return [];\n    if (predicate && !(predicate = entities[predicate])) return [];\n    if (object && !(object = entities[object])) return []; // Choose the optimal index, based on what fields are present\n\n    if (subject) {\n      if (object) // If subject and object are given, the object index will be the fastest.\n        return this._findInIndex(graphItem.objects, object, subject, predicate, 'object', 'subject', 'predicate', graph);else // If only subject and possibly predicate are given, the subject index will be the fastest.\n        return this._findInIndex(graphItem.subjects, subject, predicate, null, 'subject', 'predicate', 'object', graph);\n    } else if (predicate) // If only predicate and possibly object are given, the predicate index will be the fastest.\n      return this._findInIndex(graphItem.predicates, predicate, object, null, 'predicate', 'object', 'subject', graph);else if (object) // If only object is given, the object index will be the fastest.\n      return this._findInIndex(graphItem.objects, object, null, null, 'object', 'subject', 'predicate', graph);else // If nothing is given, iterate subjects and predicates first\n      return this._findInIndex(graphItem.subjects, null, null, null, 'subject', 'predicate', 'object', graph);\n  },\n  // ### `count` returns the number of triples matching a pattern, expanding prefixes as necessary.\n  // Setting `subject`, `predicate`, or `object` to `null` means an _anything_ wildcard.\n  // Setting `graph` to `null` means the default graph.\n  count: function count(subject, predicate, object, graph) {\n    var prefixes = this._prefixes;\n    return this.countByIRI(expandPrefixedName(subject, prefixes), expandPrefixedName(predicate, prefixes), expandPrefixedName(object, prefixes), expandPrefixedName(graph, prefixes));\n  },\n  // ### `countByIRI` returns the number of triples matching a pattern.\n  // Setting `subject`, `predicate`, or `object` to `null` means an _anything_ wildcard.\n  // Setting `graph` to `null` means the default graph.\n  countByIRI: function countByIRI(subject, predicate, object, graph) {\n    graph = graph || '';\n    var graphItem = this._graphs[graph],\n        entities = this._entities; // If the specified graph contain no triples, there are no results.\n\n    if (!graphItem) return 0; // Translate IRIs to internal index keys.\n    // Optimization: if the entity doesn't exist, no triples with it exist.\n\n    if (subject && !(subject = entities[subject])) return 0;\n    if (predicate && !(predicate = entities[predicate])) return 0;\n    if (object && !(object = entities[object])) return 0; // Choose the optimal index, based on what fields are present\n\n    if (subject) {\n      if (object) // If subject and object are given, the object index will be the fastest.\n        return this._countInIndex(graphItem.objects, object, subject, predicate);else // If only subject and possibly predicate are given, the subject index will be the fastest.\n        return this._countInIndex(graphItem.subjects, subject, predicate, object);\n    } else if (predicate) {\n      // If only predicate and possibly object are given, the predicate index will be the fastest.\n      return this._countInIndex(graphItem.predicates, predicate, object, subject);\n    } else {\n      // If only object is possibly given, the object index will be the fastest.\n      return this._countInIndex(graphItem.objects, object, subject, predicate);\n    }\n  },\n  // ### `createBlankNode` creates a new blank node, returning its name.\n  createBlankNode: function createBlankNode(suggestedName) {\n    var name, index; // Generate a name based on the suggested name\n\n    if (suggestedName) {\n      name = suggestedName = '_:' + suggestedName, index = 1;\n\n      while (this._entities[name]) {\n        name = suggestedName + index++;\n      }\n    } // Generate a generic blank node name\n    else {\n        do {\n          name = '_:b' + this._blankNodeIndex++;\n        } while (this._entities[name]);\n      } // Add the blank node to the entities, avoiding the generation of duplicates\n\n\n    this._entities[name] = ++this._entityCount;\n    return name;\n  }\n}; // ## Exports\n// Export the `N3Store` class as a whole.\n\nmodule.exports = N3Store;","map":null,"metadata":{},"sourceType":"script"}