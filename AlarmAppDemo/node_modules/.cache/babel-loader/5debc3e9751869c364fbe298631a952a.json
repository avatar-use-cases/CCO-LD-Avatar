{"ast":null,"code":"var _classCallCheck = require(\"C:\\\\Users\\\\jason\\\\Documents\\\\APG\\\\Solid\\\\generatorTest\\\\solidwakeup\\\\wakeup-react\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\jason\\\\Documents\\\\APG\\\\Solid\\\\generatorTest\\\\solidwakeup\\\\wakeup-react\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\n/**\n * Local dependencies\n */\nvar _require = require('../errors'),\n    NotSupportedError = _require.NotSupportedError;\n/**\n * KeyAlgorithm dictionary\n */\n\n\nvar KeyAlgorithm =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  /**\n   * constructor\n   *\n   * @param {object} algorithm\n   */\n  function KeyAlgorithm(algorithm) {\n    _classCallCheck(this, KeyAlgorithm);\n\n    Object.assign(this, algorithm); // validate name\n\n    if (this.name === undefined) {\n      throw new Error('KeyAlgorithm must have a name');\n    }\n  }\n  /**\n   * TODO\n   * If we split algorithm implementations away from dictionaries,\n   * we'll need to remove these abstract methods.\n   *\n   * It seems that SupportedAlgorithms covers the same ground of\n   * throwing a NotSupportedError, and these would never be invoked.\n   */\n\n  /**\n   * encrypt\n   *\n   * @description\n   * encrypt is not a supported operation for this algorithm.\n   */\n\n\n  _createClass(KeyAlgorithm, [{\n    key: \"encrypt\",\n    value: function encrypt() {\n      throw new NotSupportedError();\n    }\n    /**\n     * decrypt\n     *\n     * @description\n     * decrypt is not a supported operation for this algorithm.\n     */\n\n  }, {\n    key: \"decrypt\",\n    value: function decrypt() {\n      throw new NotSupportedError();\n    }\n    /**\n     * sign\n     *\n     * @description\n     * sign is not a supported operation for this algorithm.\n     */\n\n  }, {\n    key: \"sign\",\n    value: function sign() {\n      throw new NotSupportedError();\n    }\n    /**\n     * verify\n     *\n     * @description\n     * verify is not a supported operation for this algorithm.\n     */\n\n  }, {\n    key: \"verify\",\n    value: function verify() {\n      throw new NotSupportedError();\n    }\n    /**\n     * deriveBits\n     *\n     * @description\n     * deriveBits is not a supported operation for this algorithm.\n     */\n\n  }, {\n    key: \"deriveBits\",\n    value: function deriveBits() {\n      throw new NotSupportedError();\n    }\n    /**\n     * wrapKey\n     *\n     * @description\n     * wrapKey is not a supported operation for this algorithm.\n     */\n\n  }, {\n    key: \"wrapKey\",\n    value: function wrapKey() {\n      throw new NotSupportedError();\n    }\n    /**\n     * unwrapKey\n     *\n     * @description\n     * unwrapKey is not a supported operation for this algorithm.\n     */\n\n  }, {\n    key: \"unwrapKey\",\n    value: function unwrapKey() {\n      throw new NotSupportedError();\n    }\n    /**\n     * generateKey\n     *\n     * @description\n     * generateKey is not a supported operation for this algorithm.\n     */\n\n  }, {\n    key: \"generateKey\",\n    value: function generateKey() {\n      throw new NotSupportedError();\n    }\n    /**\n     * importKey\n     *\n     * @description\n     * @param {}\n     * @returns {}\n     */\n\n  }, {\n    key: \"importKey\",\n    value: function importKey() {\n      throw new NotSupportedError();\n    }\n    /**\n     * exportKey\n     *\n     * @description\n     * @param {}\n     * @returns {}\n     */\n\n  }, {\n    key: \"exportKey\",\n    value: function exportKey() {\n      throw new NotSupportedError();\n    }\n    /**\n     * getLength\n     *\n     * @description\n     * getLength is not a supported operation for this algorithm.\n     */\n\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      throw new NotSupportedError();\n    }\n  }]);\n\n  return KeyAlgorithm;\n}();\n/**\n * Export\n */\n\n\nmodule.exports = KeyAlgorithm;","map":null,"metadata":{},"sourceType":"script"}