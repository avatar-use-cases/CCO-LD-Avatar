{"ast":null,"code":"var _classCallCheck = require(\"C:\\\\Users\\\\jason\\\\Documents\\\\APG\\\\Solid\\\\BIGSOLID\\\\CCO-LD-Avatar\\\\AlarmAppDemo\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\jason\\\\Documents\\\\APG\\\\Solid\\\\BIGSOLID\\\\CCO-LD-Avatar\\\\AlarmAppDemo\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\jason\\\\Documents\\\\APG\\\\Solid\\\\BIGSOLID\\\\CCO-LD-Avatar\\\\AlarmAppDemo\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\jason\\\\Documents\\\\APG\\\\Solid\\\\BIGSOLID\\\\CCO-LD-Avatar\\\\AlarmAppDemo\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\jason\\\\Documents\\\\APG\\\\Solid\\\\BIGSOLID\\\\CCO-LD-Avatar\\\\AlarmAppDemo\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\n/**\n * Dependencies\n */\nvar assert = require('assert');\n\nvar fetch = require('node-fetch');\n\nvar _require = require('whatwg-url'),\n    URL = _require.URL;\n\nvar Headers = fetch.Headers ? fetch.Headers : global.Headers;\n\nvar _require2 = require('@trust/json-document'),\n    JSONDocument = _require2.JSONDocument;\n\nvar _require3 = require('@trust/jose'),\n    JWKSet = _require3.JWKSet;\n\nvar AuthenticationRequest = require('./AuthenticationRequest');\n\nvar AuthenticationResponse = require('./AuthenticationResponse');\n\nvar RelyingPartySchema = require('./RelyingPartySchema');\n\nvar onHttpError = require('./onHttpError');\n/**\n * RelyingParty\n *\n * @class\n * Client interface for OpenID Connect Relying Party.\n *\n * @example\n *  let client = RelyingParty({\n *    provider: {\n *      name: 'Anvil Research, Inc.',\n *      url: 'https://forge.anvil.io'\n *      // configuration\n *      // jwks\n *    },\n *    defaults: {\n *      popToken: false,\n *      authenticate: {\n *        response_type: 'code',\n *        display: 'popup',\n *        scope: 'openid profile email'\n *      },\n *      register: {\n *        client_name: 'Example',\n *        client_uri: 'https://example.com',\n *        logo_uri: 'https://example.com/assets/logo.png',\n *        redirect_uris: ['https://app.example.com/callback'],\n *        response_types: ['code', 'code id_token token'],\n *        grant_types: ['authorization_code'],\n *        default_max_age: 7200,\n *        post_logout_redirect_uris: ['https://app.example.com']\n *      },\n *    },\n *    registration: {\n *      // if you have it saved somewhere\n *    },\n *    store: localStorage || req.session\n *  })\n *\n *  client.discover() => Promise\n *  client.jwks() => Promise\n *  client.authenticate()\n *  client.authenticateUri()\n *  client.validateResponse(uri) => Promise\n *  client.userinfo() => Promise\n *  client.logout()\n */\n\n\nvar RelyingParty =\n/*#__PURE__*/\nfunction (_JSONDocument) {\n  \"use strict\";\n\n  _inherits(RelyingParty, _JSONDocument);\n\n  function RelyingParty() {\n    _classCallCheck(this, RelyingParty);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(RelyingParty).apply(this, arguments));\n  }\n\n  _createClass(RelyingParty, [{\n    key: \"discover\",\n\n    /**\n     * Discover\n     *\n     * @description Fetches the issuer's OpenID Configuration.\n     * @returns {Promise<Object>} Resolves with the provider configuration response\n     */\n    value: function discover() {\n      var _this = this;\n\n      try {\n        var issuer = this.provider.url;\n        assert(issuer, 'RelyingParty provider must define \"url\"');\n        var url = new URL(issuer);\n        url.pathname = '.well-known/openid-configuration';\n        return fetch(url.toString()).then(onHttpError('Error fetching openid configuration')).then(function (response) {\n          return response.json().then(function (json) {\n            return _this.provider.configuration = json;\n          });\n        });\n      } catch (error) {\n        return Promise.reject(error);\n      }\n    }\n    /**\n     * Register\n     *\n     * @description Register's a client with provider as a Relying Party\n     *\n     * @param options {Object}\n     * @returns {Promise<Object>} Resolves with the registration response object\n     */\n\n  }, {\n    key: \"register\",\n    value: function register(options) {\n      var _this2 = this;\n\n      try {\n        var configuration = this.provider.configuration;\n        assert(configuration, 'OpenID Configuration is not initialized.');\n        assert(configuration.registration_endpoint, 'OpenID Configuration is missing registration_endpoint.');\n        var uri = configuration.registration_endpoint;\n        var method = 'post';\n        var headers = new Headers({\n          'Content-Type': 'application/json'\n        });\n        var params = this.defaults.register;\n        var body = JSON.stringify(Object.assign({}, params, options));\n        return fetch(uri, {\n          method: method,\n          headers: headers,\n          body: body\n        }).then(onHttpError('Error registering client')).then(function (response) {\n          return response.json().then(function (json) {\n            return _this2.registration = json;\n          });\n        });\n      } catch (error) {\n        return Promise.reject(error);\n      }\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return JSON.stringify(this);\n    }\n    /**\n     * jwks\n     *\n     * @description Promises the issuer's JWK Set.\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"jwks\",\n    value: function jwks() {\n      var _this3 = this;\n\n      try {\n        var configuration = this.provider.configuration;\n        assert(configuration, 'OpenID Configuration is not initialized.');\n        assert(configuration.jwks_uri, 'OpenID Configuration is missing jwks_uri.');\n        var uri = configuration.jwks_uri;\n        return fetch(uri).then(onHttpError('Error resolving provider keys')).then(function (response) {\n          return response.json().then(function (json) {\n            return JWKSet.importKeys(json);\n          }).then(function (jwks) {\n            return _this3.provider.jwks = jwks;\n          });\n        });\n      } catch (error) {\n        return Promise.reject(error);\n      }\n    }\n    /**\n     * createRequest\n     *\n     * @param options {Object} Authn request options hashmap\n     * @param options.redirect_uri {string}\n     * @param options.response_type {string} e.g. 'code' or 'id_token token'\n     * @param session {Session|Storage} req.session or localStorage\n     * @returns {Promise<string>} Authn request URL\n     */\n\n  }, {\n    key: \"createRequest\",\n    value: function createRequest(options, session) {\n      return AuthenticationRequest.create(this, options, session || this.store);\n    }\n    /**\n     * Validate Response\n     *\n     * @param response {string} req.query or req.body.text\n     * @param session {Session|Storage} req.session or localStorage or similar\n     * @returns {Promise<Object>} Custom response object, with `params` and\n     *   `mode` properties\n     */\n\n  }, {\n    key: \"validateResponse\",\n    value: function validateResponse(response, session) {\n      session = session || this.store;\n\n      if (response.match(/^http(s?):\\/\\//)) {\n        response = {\n          rp: this,\n          redirect: response,\n          session: session\n        };\n      } else {\n        response = {\n          rp: this,\n          body: response,\n          session: session\n        };\n      }\n\n      return AuthenticationResponse.validateResponse(response);\n    }\n    /**\n     * userinfo\n     *\n     * @description Promises the authenticated user's claims.\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"userinfo\",\n    value: function userinfo() {\n      try {\n        var configuration = this.provider.configuration;\n        assert(configuration, 'OpenID Configuration is not initialized.');\n        assert(configuration.userinfo_endpoint, 'OpenID Configuration is missing userinfo_endpoint.');\n        var uri = configuration.userinfo_endpoint;\n        var access_token = this.store.access_token;\n        assert(access_token, 'Missing access token.');\n        var headers = new Headers({\n          'Content-Type': 'application/json',\n          'Authorization': \"Bearer \".concat(access_token)\n        });\n        return fetch(uri, {\n          headers: headers\n        }).then(onHttpError('Error fetching userinfo')).then(function (response) {\n          return response.json();\n        });\n      } catch (error) {\n        return Promise.reject(error);\n      }\n    }\n    /**\n     * Logout\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"logout\",\n    value: function logout() {\n      var configuration;\n\n      try {\n        assert(this.provider, 'OpenID Configuration is not initialized.');\n        configuration = this.provider.configuration;\n        assert(configuration, 'OpenID Configuration is not initialized.');\n        assert(configuration.end_session_endpoint, 'OpenID Configuration is missing end_session_endpoint.');\n      } catch (error) {\n        return Promise.reject(error);\n      }\n\n      this.clearSession();\n      var uri = configuration.end_session_endpoint;\n      var method = 'get';\n      return fetch(uri, {\n        method: method\n      }).then(onHttpError('Error logging out')); // TODO: Validate `frontchannel_logout_uri` if necessary\n\n      /**\n       * frontchannel_logout_uri - OPTIONAL. RP URL that will cause the RP to log\n       * itself out when rendered in an iframe by the OP.\n       *\n       * An `iss` (issuer) query parameter and a `sid`\n       * (session ID) query parameter MAY be included by the OP to enable the RP\n       * to validate the request and to determine which of the potentially\n       * multiple sessions is to be logged out. If a sid (session ID) query\n       * parameter is included, an iss (issuer) query parameter MUST also be\n       * included.\n       * @see https://openid.net/specs/openid-connect-frontchannel-1_0.html#RPLogout\n       */\n    }\n  }, {\n    key: \"clearSession\",\n    value: function clearSession() {\n      var session = this.store;\n\n      if (!session) {\n        return;\n      }\n\n      delete session[SESSION_PRIVATE_KEY];\n    }\n    /**\n     * @param uri {string} Target Resource Server URI\n     * @param idToken {IDToken} ID Token to be embedded in the PoP token\n     *\n     * @returns {Promise<PoPToken>}\n     */\n\n  }, {\n    key: \"popTokenFor\",\n    value: function popTokenFor(uri, idToken) {\n      return PoPToken.issueFor(uri, idToken);\n    }\n  }], [{\n    key: \"from\",\n\n    /**\n     * from\n     *\n     * @description\n     * Create a RelyingParty instance from a previously registered client.\n     *\n     * @param {Object} data\n     * @returns {Promise<RelyingParty>}\n     */\n    value: function from(data) {\n      var rp = new RelyingParty(data);\n      var validation = rp.validate(); // schema validation\n\n      if (!validation.valid) {\n        return Promise.reject(new Error(JSON.stringify(validation)));\n      }\n\n      var jwks = rp.provider.jwks; // request the JWK Set if missing\n\n      if (!jwks) {\n        return rp.jwks().then(function () {\n          return rp;\n        });\n      } // otherwise import the JWK Set to webcrypto\n\n\n      return JWKSet.importKeys(jwks).then(function (jwks) {\n        rp.provider.jwks = jwks;\n        return rp;\n      });\n    }\n    /**\n     * register\n     *\n     * @param issuer {string} Provider URL\n     * @param registration {Object} Client dynamic registration options\n     * @param options {Object}\n     * @param options.defaults\n     * @param [options.store] {Session|Storage}\n     * @returns {Promise<RelyingParty>} RelyingParty instance, registered.\n     */\n\n  }, {\n    key: \"register\",\n    value: function register(issuer, registration, options) {\n      var rp = new RelyingParty({\n        provider: {\n          url: issuer\n        },\n        defaults: Object.assign({}, options.defaults),\n        store: options.store\n      });\n      return Promise.resolve().then(function () {\n        return rp.discover();\n      }).then(function () {\n        return rp.jwks();\n      }).then(function () {\n        return rp.register(registration);\n      }).then(function () {\n        return rp;\n      });\n    }\n  }, {\n    key: \"schema\",\n\n    /**\n     * Schema\n     */\n    get: function get() {\n      return RelyingPartySchema;\n    }\n  }]);\n\n  return RelyingParty;\n}(JSONDocument);\n\nvar SESSION_PRIVATE_KEY = 'oidc.session.privateKey';\nRelyingParty.SESSION_PRIVATE_KEY = SESSION_PRIVATE_KEY;\nmodule.exports = RelyingParty;","map":null,"metadata":{},"sourceType":"script"}