{"ast":null,"code":"// **N3Parser** parses N3 documents.\nvar N3Lexer = require('./N3Lexer');\n\nvar RDF_PREFIX = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',\n    RDF_NIL = RDF_PREFIX + 'nil',\n    RDF_FIRST = RDF_PREFIX + 'first',\n    RDF_REST = RDF_PREFIX + 'rest';\nvar absoluteIRI = /^[a-z][a-z0-9+.-]*:/i,\n    schemeAuthority = /^(?:([a-z][a-z0-9+.-]*:))?(?:\\/\\/[^\\/]*)?/i,\n    dotSegments = /(?:^|\\/)\\.\\.?(?:$|[\\/#?])/; // The next ID for new blank nodes\n\nvar blankNodePrefix = 0,\n    blankNodeCount = 0; // ## Constructor\n\nfunction N3Parser(options) {\n  if (!(this instanceof N3Parser)) return new N3Parser(options);\n  this._tripleStack = [];\n  this._graph = null; // Set the document IRI.\n\n  options = options || {};\n\n  this._setBase(options.documentIRI); // Set supported features depending on the format.\n\n\n  var format = typeof options.format === 'string' && options.format.match(/\\w*$/)[0].toLowerCase(),\n      isTurtle = format === 'turtle',\n      isTriG = format === 'trig',\n      isNTriples = /triple/.test(format),\n      isNQuads = /quad/.test(format),\n      isLineMode = isNTriples || isNQuads;\n  if (!(this._supportsNamedGraphs = !isTurtle)) this._readPredicateOrNamedGraph = this._readPredicate;\n  this._supportsQuads = !(isTurtle || isTriG || isNTriples); // Disable relative IRIs in N-Triples or N-Quads mode\n\n  if (isLineMode) {\n    this._base = '';\n\n    this._resolveIRI = function (token) {\n      this._error('Disallowed relative IRI', token);\n\n      return this._callback = noop, this._subject = null;\n    };\n  }\n\n  this._blankNodePrefix = typeof options.blankNodePrefix !== 'string' ? '' : '_:' + options.blankNodePrefix.replace(/^_:/, '');\n  this._lexer = options.lexer || new N3Lexer({\n    lineMode: isLineMode\n  });\n} // ## Private class methods\n// ### `_resetBlankNodeIds` restarts blank node identification.\n\n\nN3Parser._resetBlankNodeIds = function () {\n  blankNodePrefix = blankNodeCount = 0;\n};\n\nN3Parser.prototype = {\n  // ## Private methods\n  // ### `_setBase` sets the base IRI to resolve relative IRIs.\n  _setBase: function _setBase(baseIRI) {\n    if (!baseIRI) baseIRI = null;else if (baseIRI.indexOf('#') >= 0) throw new Error('Invalid base IRI ' + baseIRI); // Set base IRI and its components\n\n    if (this._base = baseIRI) {\n      this._basePath = baseIRI.replace(/[^\\/?]*(?:\\?.*)?$/, '');\n      baseIRI = baseIRI.match(schemeAuthority);\n      this._baseRoot = baseIRI[0];\n      this._baseScheme = baseIRI[1];\n    }\n  },\n  // ### `_readInTopContext` reads a token when in the top context.\n  _readInTopContext: function _readInTopContext(token) {\n    switch (token.type) {\n      // If an EOF token arrives in the top context, signal that we're done.\n      case 'eof':\n        if (this._graph !== null) return this._error('Unclosed graph', token);\n        delete this._prefixes._;\n        return this._callback(null, null, this._prefixes);\n      // It could be a prefix declaration.\n\n      case '@prefix':\n        this._sparqlStyle = false;\n        return this._readPrefix;\n\n      case 'PREFIX':\n        this._sparqlStyle = true;\n        return this._readPrefix;\n      // It could be a base declaration.\n\n      case '@base':\n        this._sparqlStyle = false;\n        return this._readBaseIRI;\n\n      case 'BASE':\n        this._sparqlStyle = true;\n        return this._readBaseIRI;\n      // It could be a graph.\n\n      case '{':\n        if (this._supportsNamedGraphs) {\n          this._graph = '';\n          this._subject = null;\n          return this._readSubject;\n        }\n\n      case 'GRAPH':\n        if (this._supportsNamedGraphs) return this._readNamedGraphLabel;\n      // Otherwise, the next token must be a subject.\n\n      default:\n        return this._readSubject(token);\n    }\n  },\n  // ### `_readSubject` reads a triple's subject.\n  _readSubject: function _readSubject(token) {\n    this._predicate = null;\n\n    switch (token.type) {\n      case 'IRI':\n        if (this._base === null || absoluteIRI.test(token.value)) this._subject = token.value;else this._subject = this._resolveIRI(token);\n        break;\n\n      case 'prefixed':\n        var prefix = this._prefixes[token.prefix];\n        if (prefix === undefined) return this._error('Undefined prefix \"' + token.prefix + ':\"', token);\n        this._subject = prefix + token.value;\n        break;\n\n      case '[':\n        // Start a new triple with a new blank node as subject.\n        this._subject = '_:b' + blankNodeCount++;\n\n        this._tripleStack.push({\n          subject: this._subject,\n          predicate: null,\n          object: null,\n          type: 'blank'\n        });\n\n        return this._readBlankNodeHead;\n\n      case '(':\n        // Start a new list\n        this._tripleStack.push({\n          subject: RDF_NIL,\n          predicate: null,\n          object: null,\n          type: 'list'\n        });\n\n        this._subject = null;\n        return this._readListItem;\n\n      case '}':\n        return this._readPunctuation(token);\n\n      default:\n        return this._error('Expected subject but got ' + token.type, token);\n    } // The next token must be a predicate,\n    // or, if the subject was actually a graph IRI, a named graph.\n\n\n    return this._readPredicateOrNamedGraph;\n  },\n  // ### `_readPredicate` reads a triple's predicate.\n  _readPredicate: function _readPredicate(token) {\n    var type = token.type;\n\n    switch (type) {\n      case 'IRI':\n      case 'abbreviation':\n        if (this._base === null || absoluteIRI.test(token.value)) this._predicate = token.value;else this._predicate = this._resolveIRI(token);\n        break;\n\n      case 'prefixed':\n        if (token.prefix === '_') return this._error('Disallowed blank node as predicate', token);\n        var prefix = this._prefixes[token.prefix];\n        if (prefix === undefined) return this._error('Undefined prefix \"' + token.prefix + ':\"', token);\n        this._predicate = prefix + token.value;\n        break;\n\n      case '.':\n      case ']':\n      case '}':\n        // Expected predicate didn't come, must have been trailing semicolon.\n        if (this._predicate === null) return this._error('Unexpected ' + type, token);\n        this._subject = null;\n        return type === ']' ? this._readBlankNodeTail(token) : this._readPunctuation(token);\n\n      case ';':\n        // Extra semicolons can be safely ignored\n        return this._readPredicate;\n\n      default:\n        return this._error('Expected predicate to follow \"' + this._subject + '\"', token);\n    } // The next token must be an object.\n\n\n    return this._readObject;\n  },\n  // ### `_readObject` reads a triple's object.\n  _readObject: function _readObject(token) {\n    switch (token.type) {\n      case 'IRI':\n        if (this._base === null || absoluteIRI.test(token.value)) this._object = token.value;else this._object = this._resolveIRI(token);\n        break;\n\n      case 'prefixed':\n        var prefix = this._prefixes[token.prefix];\n        if (prefix === undefined) return this._error('Undefined prefix \"' + token.prefix + ':\"', token);\n        this._object = prefix + token.value;\n        break;\n\n      case 'literal':\n        this._object = token.value;\n        return this._readDataTypeOrLang;\n\n      case '[':\n        // Start a new triple with a new blank node as subject.\n        var blank = '_:b' + blankNodeCount++;\n\n        this._tripleStack.push({\n          subject: this._subject,\n          predicate: this._predicate,\n          object: blank,\n          type: 'blank'\n        });\n\n        this._subject = blank;\n        return this._readBlankNodeHead;\n\n      case '(':\n        // Start a new list\n        this._tripleStack.push({\n          subject: this._subject,\n          predicate: this._predicate,\n          object: RDF_NIL,\n          type: 'list'\n        });\n\n        this._subject = null;\n        return this._readListItem;\n\n      default:\n        return this._error('Expected object to follow \"' + this._predicate + '\"', token);\n    }\n\n    return this._getTripleEndReader();\n  },\n  // ### `_readPredicateOrNamedGraph` reads a triple's predicate, or a named graph.\n  _readPredicateOrNamedGraph: function _readPredicateOrNamedGraph(token) {\n    return token.type === '{' ? this._readGraph(token) : this._readPredicate(token);\n  },\n  // ### `_readGraph` reads a graph.\n  _readGraph: function _readGraph(token) {\n    if (token.type !== '{') return this._error('Expected graph but got ' + token.type, token); // The \"subject\" we read is actually the GRAPH's label\n\n    this._graph = this._subject, this._subject = null;\n    return this._readSubject;\n  },\n  // ### `_readBlankNodeHead` reads the head of a blank node.\n  _readBlankNodeHead: function _readBlankNodeHead(token) {\n    if (token.type === ']') {\n      this._subject = null;\n      return this._readBlankNodeTail(token);\n    } else {\n      this._predicate = null;\n      return this._readPredicate(token);\n    }\n  },\n  // ### `_readBlankNodeTail` reads the end of a blank node.\n  _readBlankNodeTail: function _readBlankNodeTail(token) {\n    if (token.type !== ']') return this._readBlankNodePunctuation(token); // Store blank node triple.\n\n    if (this._subject !== null) this._callback(null, {\n      subject: this._subject,\n      predicate: this._predicate,\n      object: this._object,\n      graph: this._graph || ''\n    }); // Restore parent triple that contains the blank node.\n\n    var triple = this._tripleStack.pop();\n\n    this._subject = triple.subject; // Was the blank node the object?\n\n    if (triple.object !== null) {\n      // Restore predicate and object as well, and continue by reading punctuation.\n      this._predicate = triple.predicate;\n      this._object = triple.object;\n      return this._getTripleEndReader();\n    } // The blank node was the subject, so continue reading the predicate.\n    // If the blank node didn't contain any predicates, it could also be the label of a named graph.\n\n\n    return this._predicate !== null ? this._readPredicate : this._readPredicateOrNamedGraph;\n  },\n  // ### `_readDataTypeOrLang` reads an _optional_ data type or language.\n  _readDataTypeOrLang: function _readDataTypeOrLang(token) {\n    switch (token.type) {\n      case 'type':\n        var value;\n\n        if (token.prefix === '') {\n          if (this._base === null || absoluteIRI.test(token.value)) value = token.value;else value = this._resolveIRI(token);\n        } else {\n          var prefix = this._prefixes[token.prefix];\n          if (prefix === undefined) return this._error('Undefined prefix \"' + token.prefix + ':\"', token);\n          value = prefix + token.value;\n        }\n\n        this._object += '^^' + value;\n        return this._getTripleEndReader();\n\n      case 'langcode':\n        this._object += '@' + token.value.toLowerCase();\n        return this._getTripleEndReader();\n\n      default:\n        return this._getTripleEndReader().call(this, token);\n    }\n  },\n  // ### `_readListItem` reads items from a list.\n  _readListItem: function _readListItem(token) {\n    var item = null,\n        // The actual list item.\n    itemHead = null,\n        // The head of the rdf:first predicate.\n    prevItemHead = this._subject,\n        // The head of the previous rdf:first predicate.\n    stack = this._tripleStack,\n        // The stack of triples part of recursion (lists, blanks, etc.).\n    parentTriple = stack[stack.length - 1],\n        // The triple containing the current list.\n    next = this._readListItem; // The next function to execute.\n\n    switch (token.type) {\n      case 'IRI':\n        if (this._base === null || absoluteIRI.test(token.value)) item = token.value;else item = this._resolveIRI(token);\n        break;\n\n      case 'prefixed':\n        var prefix = this._prefixes[token.prefix];\n        if (prefix === undefined) return this._error('Undefined prefix \"' + token.prefix + ':\"', token);\n        item = prefix + token.value;\n        break;\n\n      case 'literal':\n        item = token.value;\n        next = this._readDataTypeOrLang;\n        break;\n\n      case '[':\n        // Stack the current list triple and start a new triple with a blank node as subject.\n        itemHead = '_:b' + blankNodeCount++;\n        item = '_:b' + blankNodeCount++;\n        stack.push({\n          subject: itemHead,\n          predicate: RDF_FIRST,\n          object: item,\n          type: 'blank'\n        });\n        this._subject = item;\n        next = this._readBlankNodeHead;\n        break;\n\n      case '(':\n        // Stack the current list triple and start a new list\n        itemHead = '_:b' + blankNodeCount++;\n        stack.push({\n          subject: itemHead,\n          predicate: RDF_FIRST,\n          object: RDF_NIL,\n          type: 'list'\n        });\n        this._subject = null;\n        next = this._readListItem;\n        break;\n\n      case ')':\n        // Restore the parent triple.\n        stack.pop(); // If this list is contained within a parent list, return the membership triple here.\n        // This will be `<parent list element> rdf:first <this list>.`.\n\n        if (stack.length !== 0 && stack[stack.length - 1].type === 'list') this._callback(null, {\n          subject: parentTriple.subject,\n          predicate: parentTriple.predicate,\n          object: parentTriple.object,\n          graph: this._graph || ''\n        }); // Restore the parent triple's subject.\n\n        this._subject = parentTriple.subject; // Was this list in the parent triple's subject?\n\n        if (parentTriple.predicate === null) {\n          // The next token is the predicate.\n          next = this._readPredicate; // Skip writing the list tail if this was an empty list.\n\n          if (parentTriple.subject === RDF_NIL) return next;\n        } // The list was in the parent triple's object.\n        else {\n            // Restore the parent triple's predicate and object as well.\n            this._predicate = parentTriple.predicate;\n            this._object = parentTriple.object;\n            next = this._getTripleEndReader(); // Skip writing the list tail if this was an empty list.\n\n            if (parentTriple.object === RDF_NIL) return next;\n          } // Close the list by making the item head nil.\n\n\n        itemHead = RDF_NIL;\n        break;\n\n      default:\n        return this._error('Expected list item instead of \"' + token.type + '\"', token);\n    } // Create a new blank node if no item head was assigned yet.\n\n\n    if (itemHead === null) this._subject = itemHead = '_:b' + blankNodeCount++; // Is this the first element of the list?\n\n    if (prevItemHead === null) {\n      // This list is either the object or the subject.\n      if (parentTriple.object === RDF_NIL) parentTriple.object = itemHead;else parentTriple.subject = itemHead;\n    } else {\n      // The rest of the list is in the current head.\n      this._callback(null, {\n        subject: prevItemHead,\n        predicate: RDF_REST,\n        object: itemHead,\n        graph: this._graph || ''\n      });\n    } // Add the item's value.\n\n\n    if (item !== null) this._callback(null, {\n      subject: itemHead,\n      predicate: RDF_FIRST,\n      object: item,\n      graph: this._graph || ''\n    });\n    return next;\n  },\n  // ### `_readPunctuation` reads punctuation between triples or triple parts.\n  _readPunctuation: function _readPunctuation(token) {\n    var next,\n        subject = this._subject,\n        graph = this._graph;\n\n    switch (token.type) {\n      // A closing brace ends a graph\n      case '}':\n        if (this._graph === null) return this._error('Unexpected graph closing', token);\n        this._graph = null;\n      // A dot just ends the statement, without sharing anything with the next.\n\n      case '.':\n        this._subject = null;\n        next = this._readInTopContext;\n        break;\n      // Semicolon means the subject is shared; predicate and object are different.\n\n      case ';':\n        next = this._readPredicate;\n        break;\n      // Comma means both the subject and predicate are shared; the object is different.\n\n      case ',':\n        next = this._readObject;\n        break;\n      // An IRI means this is a quad (only allowed if not already inside a graph).\n\n      case 'IRI':\n        if (this._supportsQuads && this._graph === null) {\n          if (this._base === null || absoluteIRI.test(token.value)) graph = token.value;else graph = this._resolveIRI(token);\n          subject = this._subject;\n          next = this._readQuadPunctuation;\n          break;\n        }\n\n      // An prefixed name means this is a quad (only allowed if not already inside a graph).\n\n      case 'prefixed':\n        if (this._supportsQuads && this._graph === null) {\n          var prefix = this._prefixes[token.prefix];\n          if (prefix === undefined) return this._error('Undefined prefix \"' + token.prefix + ':\"', token);\n          graph = prefix + token.value;\n          next = this._readQuadPunctuation;\n          break;\n        }\n\n      default:\n        return this._error('Expected punctuation to follow \"' + this._object + '\"', token);\n    } // A triple has been completed now, so return it.\n\n\n    if (subject !== null) this._callback(null, {\n      subject: subject,\n      predicate: this._predicate,\n      object: this._object,\n      graph: graph || ''\n    });\n    return next;\n  },\n  // ### `_readBlankNodePunctuation` reads punctuation in a blank node\n  _readBlankNodePunctuation: function _readBlankNodePunctuation(token) {\n    var next;\n\n    switch (token.type) {\n      // Semicolon means the subject is shared; predicate and object are different.\n      case ';':\n        next = this._readPredicate;\n        break;\n      // Comma means both the subject and predicate are shared; the object is different.\n\n      case ',':\n        next = this._readObject;\n        break;\n\n      default:\n        return this._error('Expected punctuation to follow \"' + this._object + '\"', token);\n    } // A triple has been completed now, so return it.\n\n\n    this._callback(null, {\n      subject: this._subject,\n      predicate: this._predicate,\n      object: this._object,\n      graph: this._graph || ''\n    });\n\n    return next;\n  },\n  // ### `_readQuadPunctuation` reads punctuation after a quad.\n  _readQuadPunctuation: function _readQuadPunctuation(token) {\n    if (token.type !== '.') return this._error('Expected dot to follow quad', token);\n    return this._readInTopContext;\n  },\n  // ### `_readPrefix` reads the prefix of a prefix declaration.\n  _readPrefix: function _readPrefix(token) {\n    if (token.type !== 'prefix') return this._error('Expected prefix to follow @prefix', token);\n    this._prefix = token.value;\n    return this._readPrefixIRI;\n  },\n  // ### `_readPrefixIRI` reads the IRI of a prefix declaration.\n  _readPrefixIRI: function _readPrefixIRI(token) {\n    if (token.type !== 'IRI') return this._error('Expected IRI to follow prefix \"' + this._prefix + ':\"', token);\n    var prefixIRI;\n    if (this._base === null || absoluteIRI.test(token.value)) prefixIRI = token.value;else prefixIRI = this._resolveIRI(token);\n    this._prefixes[this._prefix] = prefixIRI;\n\n    this._prefixCallback(this._prefix, prefixIRI);\n\n    return this._readDeclarationPunctuation;\n  },\n  // ### `_readBaseIRI` reads the IRI of a base declaration.\n  _readBaseIRI: function _readBaseIRI(token) {\n    if (token.type !== 'IRI') return this._error('Expected IRI to follow base declaration', token);\n\n    try {\n      this._setBase(this._base === null || absoluteIRI.test(token.value) ? token.value : this._resolveIRI(token));\n    } catch (error) {\n      this._error(error.message, token);\n    }\n\n    return this._readDeclarationPunctuation;\n  },\n  // ### `_readNamedGraphLabel` reads the label of a named graph.\n  _readNamedGraphLabel: function _readNamedGraphLabel(token) {\n    switch (token.type) {\n      case 'IRI':\n      case 'prefixed':\n        return this._readSubject(token), this._readGraph;\n\n      case '[':\n        return this._readNamedGraphBlankLabel;\n\n      default:\n        return this._error('Invalid graph label', token);\n    }\n  },\n  // ### `_readNamedGraphLabel` reads a blank node label of a named graph.\n  _readNamedGraphBlankLabel: function _readNamedGraphBlankLabel(token) {\n    if (token.type !== ']') return this._error('Invalid graph label', token);\n    this._subject = '_:b' + blankNodeCount++;\n    return this._readGraph;\n  },\n  // ### `_readDeclarationPunctuation` reads the punctuation of a declaration.\n  _readDeclarationPunctuation: function _readDeclarationPunctuation(token) {\n    // SPARQL-style declarations don't have punctuation.\n    if (this._sparqlStyle) return this._readInTopContext(token);\n    if (token.type !== '.') return this._error('Expected declaration to end with a dot', token);\n    return this._readInTopContext;\n  },\n  // ### `_getTripleEndReader` gets the next reader function at the end of a triple.\n  _getTripleEndReader: function _getTripleEndReader() {\n    var stack = this._tripleStack;\n    if (stack.length === 0) return this._readPunctuation;\n\n    switch (stack[stack.length - 1].type) {\n      case 'blank':\n        return this._readBlankNodeTail;\n\n      case 'list':\n        return this._readListItem;\n    }\n  },\n  // ### `_error` emits an error message through the callback.\n  _error: function _error(message, token) {\n    this._callback(new Error(message + ' at line ' + token.line + '.'));\n  },\n  // ### `_resolveIRI` resolves a relative IRI token against the base path,\n  // assuming that a base path has been set and that the IRI is indeed relative.\n  _resolveIRI: function _resolveIRI(token) {\n    var iri = token.value;\n\n    switch (iri[0]) {\n      // An empty relative IRI indicates the base IRI\n      case undefined:\n        return this._base;\n      // Resolve relative fragment IRIs against the base IRI\n\n      case '#':\n        return this._base + iri;\n      // Resolve relative query string IRIs by replacing the query string\n\n      case '?':\n        return this._base.replace(/(?:\\?.*)?$/, iri);\n      // Resolve root-relative IRIs at the root of the base IRI\n\n      case '/':\n        // Resolve scheme-relative IRIs to the scheme\n        return (iri[1] === '/' ? this._baseScheme : this._baseRoot) + this._removeDotSegments(iri);\n      // Resolve all other IRIs at the base IRI's path\n\n      default:\n        return this._removeDotSegments(this._basePath + iri);\n    }\n  },\n  // ### `_removeDotSegments` resolves './' and '../' path segments in an IRI as per RFC3986.\n  _removeDotSegments: function _removeDotSegments(iri) {\n    // Don't modify the IRI if it does not contain any dot segments\n    if (!dotSegments.test(iri)) return iri; // Start with an imaginary slash before the IRI in order to resolve trailing './' and '../'\n\n    var result = '',\n        length = iri.length,\n        i = -1,\n        pathStart = -1,\n        segmentStart = 0,\n        next = '/';\n\n    while (i < length) {\n      switch (next) {\n        // The path starts with the first slash after the authority\n        case ':':\n          if (pathStart < 0) {\n            // Skip two slashes before the authority\n            if (iri[++i] === '/' && iri[++i] === '/') // Skip to slash after the authority\n              while ((pathStart = i + 1) < length && iri[pathStart] !== '/') {\n                i = pathStart;\n              }\n          }\n\n          break;\n        // Don't modify a query string or fragment\n\n        case '?':\n        case '#':\n          i = length;\n          break;\n        // Handle '/.' or '/..' path segments\n\n        case '/':\n          if (iri[i + 1] === '.') {\n            next = iri[++i + 1];\n\n            switch (next) {\n              // Remove a '/.' segment\n              case '/':\n                result += iri.substring(segmentStart, i - 1);\n                segmentStart = i + 1;\n                break;\n              // Remove a trailing '/.' segment\n\n              case undefined:\n              case '?':\n              case '#':\n                return result + iri.substring(segmentStart, i) + iri.substr(i + 1);\n              // Remove a '/..' segment\n\n              case '.':\n                next = iri[++i + 1];\n\n                if (next === undefined || next === '/' || next === '?' || next === '#') {\n                  result += iri.substring(segmentStart, i - 2); // Try to remove the parent path from result\n\n                  if ((segmentStart = result.lastIndexOf('/')) >= pathStart) result = result.substr(0, segmentStart); // Remove a trailing '/..' segment\n\n                  if (next !== '/') return result + '/' + iri.substr(i + 1);\n                  segmentStart = i + 1;\n                }\n\n            }\n          }\n\n      }\n\n      next = iri[++i];\n    }\n\n    return result + iri.substring(segmentStart);\n  },\n  // ## Public methods\n  // ### `parse` parses the N3 input and emits each parsed triple through the callback.\n  parse: function parse(input, tripleCallback, prefixCallback) {\n    // The read callback is the next function to be executed when a token arrives.\n    // We start reading in the top context.\n    this._readCallback = this._readInTopContext;\n    this._prefixes = Object.create(null);\n    this._prefixes._ = this._blankNodePrefix || '_:b' + blankNodePrefix++ + '_'; // If the input argument is not given, shift parameters\n\n    if (typeof input === 'function') prefixCallback = tripleCallback, tripleCallback = input, input = null; // Set the triple and prefix callbacks.\n\n    this._callback = tripleCallback || noop;\n    this._prefixCallback = prefixCallback || noop; // Execute the read callback when a token arrives.\n\n    var self = this;\n\n    this._lexer.tokenize(input, function (error, token) {\n      if (error !== null) self._callback(error), self._callback = noop;else if (self._readCallback !== undefined) self._readCallback = self._readCallback(token);\n    }); // If no input was given, it can be added with `addChunk` and ended with `end`\n\n\n    if (!input) {\n      this.addChunk = this._lexer.addChunk;\n      this.end = this._lexer.end;\n    }\n  }\n}; // The empty function\n\nfunction noop() {} // ## Exports\n// Export the `N3Parser` class as a whole.\n\n\nmodule.exports = N3Parser;","map":null,"metadata":{},"sourceType":"script"}