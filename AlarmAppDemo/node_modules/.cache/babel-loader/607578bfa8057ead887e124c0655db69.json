{"ast":null,"code":"/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n * @version   2.3.0\n */\n(function () {\n  \"use strict\";\n\n  function lib$es6$promise$utils$$objectOrFunction(x) {\n    return typeof x === 'function' || typeof x === 'object' && x !== null;\n  }\n\n  function lib$es6$promise$utils$$isFunction(x) {\n    return typeof x === 'function';\n  }\n\n  function lib$es6$promise$utils$$isMaybeThenable(x) {\n    return typeof x === 'object' && x !== null;\n  }\n\n  var lib$es6$promise$utils$$_isArray;\n\n  if (!Array.isArray) {\n    lib$es6$promise$utils$$_isArray = function lib$es6$promise$utils$$_isArray(x) {\n      return Object.prototype.toString.call(x) === '[object Array]';\n    };\n  } else {\n    lib$es6$promise$utils$$_isArray = Array.isArray;\n  }\n\n  var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;\n  var lib$es6$promise$asap$$len = 0;\n  var lib$es6$promise$asap$$toString = {}.toString;\n  var lib$es6$promise$asap$$vertxNext;\n  var lib$es6$promise$asap$$customSchedulerFn;\n\n  var lib$es6$promise$asap$$asap = function asap(callback, arg) {\n    lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;\n    lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;\n    lib$es6$promise$asap$$len += 2;\n\n    if (lib$es6$promise$asap$$len === 2) {\n      // If len is 2, that means that we need to schedule an async flush.\n      // If additional callbacks are queued before the queue is flushed, they\n      // will be processed by this flush that we are scheduling.\n      if (lib$es6$promise$asap$$customSchedulerFn) {\n        lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);\n      } else {\n        lib$es6$promise$asap$$scheduleFlush();\n      }\n    }\n  };\n\n  function lib$es6$promise$asap$$setScheduler(scheduleFn) {\n    lib$es6$promise$asap$$customSchedulerFn = scheduleFn;\n  }\n\n  function lib$es6$promise$asap$$setAsap(asapFn) {\n    lib$es6$promise$asap$$asap = asapFn;\n  }\n\n  var lib$es6$promise$asap$$browserWindow = typeof window !== 'undefined' ? window : undefined;\n  var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};\n  var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;\n  var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]'; // test for web worker but not in IE10\n\n  var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined'; // node\n\n  function lib$es6$promise$asap$$useNextTick() {\n    var nextTick = process.nextTick; // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n    // setImmediate should be used instead instead\n\n    var version = process.versions.node.match(/^(?:(\\d+)\\.)?(?:(\\d+)\\.)?(\\*|\\d+)$/);\n\n    if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {\n      nextTick = setImmediate;\n    }\n\n    return function () {\n      nextTick(lib$es6$promise$asap$$flush);\n    };\n  } // vertx\n\n\n  function lib$es6$promise$asap$$useVertxTimer() {\n    return function () {\n      lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);\n    };\n  }\n\n  function lib$es6$promise$asap$$useMutationObserver() {\n    var iterations = 0;\n    var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);\n    var node = document.createTextNode('');\n    observer.observe(node, {\n      characterData: true\n    });\n    return function () {\n      node.data = iterations = ++iterations % 2;\n    };\n  } // web worker\n\n\n  function lib$es6$promise$asap$$useMessageChannel() {\n    var channel = new MessageChannel();\n    channel.port1.onmessage = lib$es6$promise$asap$$flush;\n    return function () {\n      channel.port2.postMessage(0);\n    };\n  }\n\n  function lib$es6$promise$asap$$useSetTimeout() {\n    return function () {\n      setTimeout(lib$es6$promise$asap$$flush, 1);\n    };\n  }\n\n  var lib$es6$promise$asap$$queue = new Array(1000);\n\n  function lib$es6$promise$asap$$flush() {\n    for (var i = 0; i < lib$es6$promise$asap$$len; i += 2) {\n      var callback = lib$es6$promise$asap$$queue[i];\n      var arg = lib$es6$promise$asap$$queue[i + 1];\n      callback(arg);\n      lib$es6$promise$asap$$queue[i] = undefined;\n      lib$es6$promise$asap$$queue[i + 1] = undefined;\n    }\n\n    lib$es6$promise$asap$$len = 0;\n  }\n\n  function lib$es6$promise$asap$$attemptVertex() {\n    try {\n      var r = require;\n      var vertx = r('vertx');\n      lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n      return lib$es6$promise$asap$$useVertxTimer();\n    } catch (e) {\n      return lib$es6$promise$asap$$useSetTimeout();\n    }\n  }\n\n  var lib$es6$promise$asap$$scheduleFlush; // Decide what async method to use to triggering processing of queued callbacks:\n\n  if (lib$es6$promise$asap$$isNode) {\n    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();\n  } else if (lib$es6$promise$asap$$BrowserMutationObserver) {\n    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();\n  } else if (lib$es6$promise$asap$$isWorker) {\n    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();\n  } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {\n    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertex();\n  } else {\n    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();\n  }\n\n  function lib$es6$promise$$internal$$noop() {}\n\n  var lib$es6$promise$$internal$$PENDING = void 0;\n  var lib$es6$promise$$internal$$FULFILLED = 1;\n  var lib$es6$promise$$internal$$REJECTED = 2;\n  var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n  function lib$es6$promise$$internal$$selfFullfillment() {\n    return new TypeError(\"You cannot resolve a promise with itself\");\n  }\n\n  function lib$es6$promise$$internal$$cannotReturnOwn() {\n    return new TypeError('A promises callback cannot return that same promise.');\n  }\n\n  function lib$es6$promise$$internal$$getThen(promise) {\n    try {\n      return promise.then;\n    } catch (error) {\n      lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;\n      return lib$es6$promise$$internal$$GET_THEN_ERROR;\n    }\n  }\n\n  function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n    try {\n      then.call(value, fulfillmentHandler, rejectionHandler);\n    } catch (e) {\n      return e;\n    }\n  }\n\n  function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {\n    lib$es6$promise$asap$$asap(function (promise) {\n      var sealed = false;\n      var error = lib$es6$promise$$internal$$tryThen(then, thenable, function (value) {\n        if (sealed) {\n          return;\n        }\n\n        sealed = true;\n\n        if (thenable !== value) {\n          lib$es6$promise$$internal$$resolve(promise, value);\n        } else {\n          lib$es6$promise$$internal$$fulfill(promise, value);\n        }\n      }, function (reason) {\n        if (sealed) {\n          return;\n        }\n\n        sealed = true;\n        lib$es6$promise$$internal$$reject(promise, reason);\n      }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n      if (!sealed && error) {\n        sealed = true;\n        lib$es6$promise$$internal$$reject(promise, error);\n      }\n    }, promise);\n  }\n\n  function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {\n    if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {\n      lib$es6$promise$$internal$$fulfill(promise, thenable._result);\n    } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {\n      lib$es6$promise$$internal$$reject(promise, thenable._result);\n    } else {\n      lib$es6$promise$$internal$$subscribe(thenable, undefined, function (value) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      }, function (reason) {\n        lib$es6$promise$$internal$$reject(promise, reason);\n      });\n    }\n  }\n\n  function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {\n    if (maybeThenable.constructor === promise.constructor) {\n      lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);\n    } else {\n      var then = lib$es6$promise$$internal$$getThen(maybeThenable);\n\n      if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {\n        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);\n      } else if (then === undefined) {\n        lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n      } else if (lib$es6$promise$utils$$isFunction(then)) {\n        lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);\n      } else {\n        lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n      }\n    }\n  }\n\n  function lib$es6$promise$$internal$$resolve(promise, value) {\n    if (promise === value) {\n      lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFullfillment());\n    } else if (lib$es6$promise$utils$$objectOrFunction(value)) {\n      lib$es6$promise$$internal$$handleMaybeThenable(promise, value);\n    } else {\n      lib$es6$promise$$internal$$fulfill(promise, value);\n    }\n  }\n\n  function lib$es6$promise$$internal$$publishRejection(promise) {\n    if (promise._onerror) {\n      promise._onerror(promise._result);\n    }\n\n    lib$es6$promise$$internal$$publish(promise);\n  }\n\n  function lib$es6$promise$$internal$$fulfill(promise, value) {\n    if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n      return;\n    }\n\n    promise._result = value;\n    promise._state = lib$es6$promise$$internal$$FULFILLED;\n\n    if (promise._subscribers.length !== 0) {\n      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);\n    }\n  }\n\n  function lib$es6$promise$$internal$$reject(promise, reason) {\n    if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n      return;\n    }\n\n    promise._state = lib$es6$promise$$internal$$REJECTED;\n    promise._result = reason;\n    lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);\n  }\n\n  function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n    var subscribers = parent._subscribers;\n    var length = subscribers.length;\n    parent._onerror = null;\n    subscribers[length] = child;\n    subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;\n    subscribers[length + lib$es6$promise$$internal$$REJECTED] = onRejection;\n\n    if (length === 0 && parent._state) {\n      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);\n    }\n  }\n\n  function lib$es6$promise$$internal$$publish(promise) {\n    var subscribers = promise._subscribers;\n    var settled = promise._state;\n\n    if (subscribers.length === 0) {\n      return;\n    }\n\n    var child,\n        callback,\n        detail = promise._result;\n\n    for (var i = 0; i < subscribers.length; i += 3) {\n      child = subscribers[i];\n      callback = subscribers[i + settled];\n\n      if (child) {\n        lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);\n      } else {\n        callback(detail);\n      }\n    }\n\n    promise._subscribers.length = 0;\n  }\n\n  function lib$es6$promise$$internal$$ErrorObject() {\n    this.error = null;\n  }\n\n  var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n  function lib$es6$promise$$internal$$tryCatch(callback, detail) {\n    try {\n      return callback(detail);\n    } catch (e) {\n      lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;\n      return lib$es6$promise$$internal$$TRY_CATCH_ERROR;\n    }\n  }\n\n  function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {\n    var hasCallback = lib$es6$promise$utils$$isFunction(callback),\n        value,\n        error,\n        succeeded,\n        failed;\n\n    if (hasCallback) {\n      value = lib$es6$promise$$internal$$tryCatch(callback, detail);\n\n      if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {\n        failed = true;\n        error = value.error;\n        value = null;\n      } else {\n        succeeded = true;\n      }\n\n      if (promise === value) {\n        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());\n        return;\n      }\n    } else {\n      value = detail;\n      succeeded = true;\n    }\n\n    if (promise._state !== lib$es6$promise$$internal$$PENDING) {// noop\n    } else if (hasCallback && succeeded) {\n      lib$es6$promise$$internal$$resolve(promise, value);\n    } else if (failed) {\n      lib$es6$promise$$internal$$reject(promise, error);\n    } else if (settled === lib$es6$promise$$internal$$FULFILLED) {\n      lib$es6$promise$$internal$$fulfill(promise, value);\n    } else if (settled === lib$es6$promise$$internal$$REJECTED) {\n      lib$es6$promise$$internal$$reject(promise, value);\n    }\n  }\n\n  function lib$es6$promise$$internal$$initializePromise(promise, resolver) {\n    try {\n      resolver(function resolvePromise(value) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      }, function rejectPromise(reason) {\n        lib$es6$promise$$internal$$reject(promise, reason);\n      });\n    } catch (e) {\n      lib$es6$promise$$internal$$reject(promise, e);\n    }\n  }\n\n  function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {\n    var enumerator = this;\n    enumerator._instanceConstructor = Constructor;\n    enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n    if (enumerator._validateInput(input)) {\n      enumerator._input = input;\n      enumerator.length = input.length;\n      enumerator._remaining = input.length;\n\n      enumerator._init();\n\n      if (enumerator.length === 0) {\n        lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n      } else {\n        enumerator.length = enumerator.length || 0;\n\n        enumerator._enumerate();\n\n        if (enumerator._remaining === 0) {\n          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n        }\n      }\n    } else {\n      lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());\n    }\n  }\n\n  lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function (input) {\n    return lib$es6$promise$utils$$isArray(input);\n  };\n\n  lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function () {\n    return new Error('Array Methods must be provided an Array');\n  };\n\n  lib$es6$promise$enumerator$$Enumerator.prototype._init = function () {\n    this._result = new Array(this.length);\n  };\n\n  var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;\n\n  lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function () {\n    var enumerator = this;\n    var length = enumerator.length;\n    var promise = enumerator.promise;\n    var input = enumerator._input;\n\n    for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n      enumerator._eachEntry(input[i], i);\n    }\n  };\n\n  lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function (entry, i) {\n    var enumerator = this;\n    var c = enumerator._instanceConstructor;\n\n    if (lib$es6$promise$utils$$isMaybeThenable(entry)) {\n      if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {\n        entry._onerror = null;\n\n        enumerator._settledAt(entry._state, i, entry._result);\n      } else {\n        enumerator._willSettleAt(c.resolve(entry), i);\n      }\n    } else {\n      enumerator._remaining--;\n      enumerator._result[i] = entry;\n    }\n  };\n\n  lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function (state, i, value) {\n    var enumerator = this;\n    var promise = enumerator.promise;\n\n    if (promise._state === lib$es6$promise$$internal$$PENDING) {\n      enumerator._remaining--;\n\n      if (state === lib$es6$promise$$internal$$REJECTED) {\n        lib$es6$promise$$internal$$reject(promise, value);\n      } else {\n        enumerator._result[i] = value;\n      }\n    }\n\n    if (enumerator._remaining === 0) {\n      lib$es6$promise$$internal$$fulfill(promise, enumerator._result);\n    }\n  };\n\n  lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function (promise, i) {\n    var enumerator = this;\n    lib$es6$promise$$internal$$subscribe(promise, undefined, function (value) {\n      enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);\n    }, function (reason) {\n      enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);\n    });\n  };\n\n  function lib$es6$promise$promise$all$$all(entries) {\n    return new lib$es6$promise$enumerator$$default(this, entries).promise;\n  }\n\n  var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;\n\n  function lib$es6$promise$promise$race$$race(entries) {\n    /*jshint validthis:true */\n    var Constructor = this;\n    var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n    if (!lib$es6$promise$utils$$isArray(entries)) {\n      lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n      return promise;\n    }\n\n    var length = entries.length;\n\n    function onFulfillment(value) {\n      lib$es6$promise$$internal$$resolve(promise, value);\n    }\n\n    function onRejection(reason) {\n      lib$es6$promise$$internal$$reject(promise, reason);\n    }\n\n    for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n      lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n    }\n\n    return promise;\n  }\n\n  var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;\n\n  function lib$es6$promise$promise$resolve$$resolve(object) {\n    /*jshint validthis:true */\n    var Constructor = this;\n\n    if (object && typeof object === 'object' && object.constructor === Constructor) {\n      return object;\n    }\n\n    var promise = new Constructor(lib$es6$promise$$internal$$noop);\n    lib$es6$promise$$internal$$resolve(promise, object);\n    return promise;\n  }\n\n  var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;\n\n  function lib$es6$promise$promise$reject$$reject(reason) {\n    /*jshint validthis:true */\n    var Constructor = this;\n    var promise = new Constructor(lib$es6$promise$$internal$$noop);\n    lib$es6$promise$$internal$$reject(promise, reason);\n    return promise;\n  }\n\n  var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;\n  var lib$es6$promise$promise$$counter = 0;\n\n  function lib$es6$promise$promise$$needsResolver() {\n    throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n  }\n\n  function lib$es6$promise$promise$$needsNew() {\n    throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n  }\n\n  var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;\n  /**\n    Promise objects represent the eventual result of an asynchronous operation. The\n    primary way of interacting with a promise is through its `then` method, which\n    registers callbacks to receive either a promise's eventual value or the reason\n    why the promise cannot be fulfilled.\n     Terminology\n    -----------\n     - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n    - `thenable` is an object or function that defines a `then` method.\n    - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n    - `exception` is a value that is thrown using the throw statement.\n    - `reason` is a value that indicates why a promise was rejected.\n    - `settled` the final resting state of a promise, fulfilled or rejected.\n     A promise can be in one of three states: pending, fulfilled, or rejected.\n     Promises that are fulfilled have a fulfillment value and are in the fulfilled\n    state.  Promises that are rejected have a rejection reason and are in the\n    rejected state.  A fulfillment value is never a thenable.\n     Promises can also be said to *resolve* a value.  If this value is also a\n    promise, then the original promise's settled state will match the value's\n    settled state.  So a promise that *resolves* a promise that rejects will\n    itself reject, and a promise that *resolves* a promise that fulfills will\n    itself fulfill.\n      Basic Usage:\n    ------------\n     ```js\n    var promise = new Promise(function(resolve, reject) {\n      // on success\n      resolve(value);\n       // on failure\n      reject(reason);\n    });\n     promise.then(function(value) {\n      // on fulfillment\n    }, function(reason) {\n      // on rejection\n    });\n    ```\n     Advanced Usage:\n    ---------------\n     Promises shine when abstracting away asynchronous interactions such as\n    `XMLHttpRequest`s.\n     ```js\n    function getJSON(url) {\n      return new Promise(function(resolve, reject){\n        var xhr = new XMLHttpRequest();\n         xhr.open('GET', url);\n        xhr.onreadystatechange = handler;\n        xhr.responseType = 'json';\n        xhr.setRequestHeader('Accept', 'application/json');\n        xhr.send();\n         function handler() {\n          if (this.readyState === this.DONE) {\n            if (this.status === 200) {\n              resolve(this.response);\n            } else {\n              reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n            }\n          }\n        };\n      });\n    }\n     getJSON('/posts.json').then(function(json) {\n      // on fulfillment\n    }, function(reason) {\n      // on rejection\n    });\n    ```\n     Unlike callbacks, promises are great composable primitives.\n     ```js\n    Promise.all([\n      getJSON('/posts'),\n      getJSON('/comments')\n    ]).then(function(values){\n      values[0] // => postsJSON\n      values[1] // => commentsJSON\n       return values;\n    });\n    ```\n     @class Promise\n    @param {function} resolver\n    Useful for tooling.\n    @constructor\n  */\n\n  function lib$es6$promise$promise$$Promise(resolver) {\n    this._id = lib$es6$promise$promise$$counter++;\n    this._state = undefined;\n    this._result = undefined;\n    this._subscribers = [];\n\n    if (lib$es6$promise$$internal$$noop !== resolver) {\n      if (!lib$es6$promise$utils$$isFunction(resolver)) {\n        lib$es6$promise$promise$$needsResolver();\n      }\n\n      if (!(this instanceof lib$es6$promise$promise$$Promise)) {\n        lib$es6$promise$promise$$needsNew();\n      }\n\n      lib$es6$promise$$internal$$initializePromise(this, resolver);\n    }\n  }\n\n  lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;\n  lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;\n  lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;\n  lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;\n  lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;\n  lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;\n  lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;\n  lib$es6$promise$promise$$Promise.prototype = {\n    constructor: lib$es6$promise$promise$$Promise,\n\n    /**\n      The primary way of interacting with a promise is through its `then` method,\n      which registers callbacks to receive either a promise's eventual value or the\n      reason why the promise cannot be fulfilled.\n       ```js\n      findUser().then(function(user){\n        // user is available\n      }, function(reason){\n        // user is unavailable, and you are given the reason why\n      });\n      ```\n       Chaining\n      --------\n       The return value of `then` is itself a promise.  This second, 'downstream'\n      promise is resolved with the return value of the first promise's fulfillment\n      or rejection handler, or rejected if the handler throws an exception.\n       ```js\n      findUser().then(function (user) {\n        return user.name;\n      }, function (reason) {\n        return 'default name';\n      }).then(function (userName) {\n        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n        // will be `'default name'`\n      });\n       findUser().then(function (user) {\n        throw new Error('Found user, but still unhappy');\n      }, function (reason) {\n        throw new Error('`findUser` rejected and we're unhappy');\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n      });\n      ```\n      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n       ```js\n      findUser().then(function (user) {\n        throw new PedagogicalException('Upstream error');\n      }).then(function (value) {\n        // never reached\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // The `PedgagocialException` is propagated all the way down to here\n      });\n      ```\n       Assimilation\n      ------------\n       Sometimes the value you want to propagate to a downstream promise can only be\n      retrieved asynchronously. This can be achieved by returning a promise in the\n      fulfillment or rejection handler. The downstream promise will then be pending\n      until the returned promise is settled. This is called *assimilation*.\n       ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // The user's comments are now available\n      });\n      ```\n       If the assimliated promise rejects, then the downstream promise will also reject.\n       ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // If `findCommentsByAuthor` fulfills, we'll have the value here\n      }, function (reason) {\n        // If `findCommentsByAuthor` rejects, we'll have the reason here\n      });\n      ```\n       Simple Example\n      --------------\n       Synchronous Example\n       ```javascript\n      var result;\n       try {\n        result = findResult();\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n       Errback Example\n       ```js\n      findResult(function(result, err){\n        if (err) {\n          // failure\n        } else {\n          // success\n        }\n      });\n      ```\n       Promise Example;\n       ```javascript\n      findResult().then(function(result){\n        // success\n      }, function(reason){\n        // failure\n      });\n      ```\n       Advanced Example\n      --------------\n       Synchronous Example\n       ```javascript\n      var author, books;\n       try {\n        author = findAuthor();\n        books  = findBooksByAuthor(author);\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n       Errback Example\n       ```js\n       function foundBooks(books) {\n       }\n       function failure(reason) {\n       }\n       findAuthor(function(author, err){\n        if (err) {\n          failure(err);\n          // failure\n        } else {\n          try {\n            findBoooksByAuthor(author, function(books, err) {\n              if (err) {\n                failure(err);\n              } else {\n                try {\n                  foundBooks(books);\n                } catch(reason) {\n                  failure(reason);\n                }\n              }\n            });\n          } catch(error) {\n            failure(err);\n          }\n          // success\n        }\n      });\n      ```\n       Promise Example;\n       ```javascript\n      findAuthor().\n        then(findBooksByAuthor).\n        then(function(books){\n          // found books\n      }).catch(function(reason){\n        // something went wrong\n      });\n      ```\n       @method then\n      @param {Function} onFulfilled\n      @param {Function} onRejected\n      Useful for tooling.\n      @return {Promise}\n    */\n    then: function then(onFulfillment, onRejection) {\n      var parent = this;\n      var state = parent._state;\n\n      if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {\n        return this;\n      }\n\n      var child = new this.constructor(lib$es6$promise$$internal$$noop);\n      var result = parent._result;\n\n      if (state) {\n        var callback = arguments[state - 1];\n        lib$es6$promise$asap$$asap(function () {\n          lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);\n        });\n      } else {\n        lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n      }\n\n      return child;\n    },\n\n    /**\n      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n      as the catch block of a try/catch statement.\n       ```js\n      function findAuthor(){\n        throw new Error('couldn't find that author');\n      }\n       // synchronous\n      try {\n        findAuthor();\n      } catch(reason) {\n        // something went wrong\n      }\n       // async with promises\n      findAuthor().catch(function(reason){\n        // something went wrong\n      });\n      ```\n       @method catch\n      @param {Function} onRejection\n      Useful for tooling.\n      @return {Promise}\n    */\n    'catch': function _catch(onRejection) {\n      return this.then(null, onRejection);\n    }\n  };\n\n  function lib$es6$promise$polyfill$$polyfill() {\n    var local;\n\n    if (typeof global !== 'undefined') {\n      local = global;\n    } else if (typeof self !== 'undefined') {\n      local = self;\n    } else {\n      try {\n        local = Function('return this')();\n      } catch (e) {\n        throw new Error('polyfill failed because global object is unavailable in this environment');\n      }\n    }\n\n    var P = local.Promise;\n\n    if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {\n      return;\n    }\n\n    local.Promise = lib$es6$promise$promise$$default;\n  }\n\n  var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;\n  var lib$es6$promise$umd$$ES6Promise = {\n    'Promise': lib$es6$promise$promise$$default,\n    'polyfill': lib$es6$promise$polyfill$$default\n  };\n  /* global define:true module:true window: true */\n\n  if (typeof define === 'function' && define['amd']) {\n    define(function () {\n      return lib$es6$promise$umd$$ES6Promise;\n    });\n  } else if (typeof module !== 'undefined' && module['exports']) {\n    module['exports'] = lib$es6$promise$umd$$ES6Promise;\n  } else if (typeof this !== 'undefined') {\n    this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;\n  }\n\n  lib$es6$promise$polyfill$$default();\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}