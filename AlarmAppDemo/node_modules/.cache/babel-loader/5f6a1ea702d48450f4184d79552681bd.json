{"ast":null,"code":"// **N3Writer** writes N3 documents.\n// Matches a literal as represented in memory by the N3 library\nvar N3LiteralMatcher = /^\"([^]*)\"(?:\\^\\^(.+)|@([\\-a-z]+))?$/i; // rdf:type predicate (for 'a' abbreviation)\n\nvar RDF_PREFIX = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',\n    RDF_TYPE = RDF_PREFIX + 'type'; // Characters in literals that require escaping\n\nvar escape = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019\\ud800-\\udbff]/,\n    escapeAll = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019]|[\\ud800-\\udbff][\\udc00-\\udfff]/g,\n    escapeReplacements = {\n  '\\\\': '\\\\\\\\',\n  '\"': '\\\\\"',\n  '\\t': '\\\\t',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\b': '\\\\b',\n  '\\f': '\\\\f'\n}; // ## Constructor\n\nfunction N3Writer(outputStream, options) {\n  if (!(this instanceof N3Writer)) return new N3Writer(outputStream, options); // Shift arguments if the first argument is not a stream\n\n  if (outputStream && typeof outputStream.write !== 'function') options = outputStream, outputStream = null;\n  options = options || {}; // If no output stream given, send the output as string through the end callback\n\n  if (!outputStream) {\n    var output = '';\n    this._outputStream = {\n      write: function write(chunk, encoding, done) {\n        output += chunk;\n        done && done();\n      },\n      end: function end(done) {\n        done && done(null, output);\n      }\n    };\n    this._endStream = true;\n  } else {\n    this._outputStream = outputStream;\n    this._endStream = options.end === undefined ? true : !!options.end;\n  } // Initialize writer, depending on the format\n\n\n  this._subject = null;\n\n  if (!/triple|quad/i.test(options.format)) {\n    this._graph = '';\n    this._prefixIRIs = Object.create(null);\n    options.prefixes && this.addPrefixes(options.prefixes);\n  } else {\n    this._writeTriple = this._writeTripleLine;\n  }\n}\n\nN3Writer.prototype = {\n  // ## Private methods\n  // ### `_write` writes the argument to the output stream\n  _write: function _write(string, callback) {\n    this._outputStream.write(string, 'utf8', callback);\n  },\n  // ### `_writeTriple` writes the triple to the output stream\n  _writeTriple: function _writeTriple(subject, predicate, object, graph, done) {\n    try {\n      // Write the graph's label if it has changed\n      if (this._graph !== graph) {\n        // Close the previous graph and start the new one\n        this._write((this._subject === null ? '' : this._graph ? '\\n}\\n' : '.\\n') + (graph ? this._encodeIriOrBlankNode(graph) + ' {\\n' : ''));\n\n        this._subject = null; // Don't treat identical blank nodes as repeating graphs\n\n        this._graph = graph[0] !== '[' ? graph : ']';\n      } // Don't repeat the subject if it's the same\n\n\n      if (this._subject === subject) {\n        // Don't repeat the predicate if it's the same\n        if (this._predicate === predicate) this._write(', ' + this._encodeObject(object), done); // Same subject, different predicate\n        else this._write(';\\n    ' + this._encodePredicate(this._predicate = predicate) + ' ' + this._encodeObject(object), done);\n      } // Different subject; write the whole triple\n      else this._write((this._subject === null ? '' : '.\\n') + this._encodeSubject(this._subject = subject) + ' ' + this._encodePredicate(this._predicate = predicate) + ' ' + this._encodeObject(object), done);\n    } catch (error) {\n      done && done(error);\n    }\n  },\n  // ### `_writeTripleLine` writes the triple or quad to the output stream as a single line\n  _writeTripleLine: function _writeTripleLine(subject, predicate, object, graph, done) {\n    // Don't use prefixes\n    delete this._prefixMatch; // Write the triple\n\n    try {\n      this._write(this._encodeIriOrBlankNode(subject) + ' ' + this._encodeIriOrBlankNode(predicate) + ' ' + this._encodeObject(object) + (graph ? ' ' + this._encodeIriOrBlankNode(graph) + '.\\n' : '.\\n'), done);\n    } catch (error) {\n      done && done(error);\n    }\n  },\n  // ### `_encodeIriOrBlankNode` represents an IRI or blank node\n  _encodeIriOrBlankNode: function _encodeIriOrBlankNode(entity) {\n    // A blank node or list is represented as-is\n    var firstChar = entity[0];\n    if (firstChar === '[' || firstChar === '(' || firstChar === '_' && entity[1] === ':') return entity; // Escape special characters\n\n    if (escape.test(entity)) entity = entity.replace(escapeAll, characterReplacer); // Try to represent the IRI as prefixed name\n\n    var prefixMatch = this._prefixRegex.exec(entity);\n\n    return !prefixMatch ? '<' + entity + '>' : !prefixMatch[1] ? entity : this._prefixIRIs[prefixMatch[1]] + prefixMatch[2];\n  },\n  // ### `_encodeLiteral` represents a literal\n  _encodeLiteral: function _encodeLiteral(value, type, language) {\n    // Escape special characters\n    if (escape.test(value)) value = value.replace(escapeAll, characterReplacer); // Write the literal, possibly with type or language\n\n    if (language) return '\"' + value + '\"@' + language;else if (type) return '\"' + value + '\"^^' + this._encodeIriOrBlankNode(type);else return '\"' + value + '\"';\n  },\n  // ### `_encodeSubject` represents a subject\n  _encodeSubject: function _encodeSubject(subject) {\n    if (subject[0] === '\"') throw new Error('A literal as subject is not allowed: ' + subject); // Don't treat identical blank nodes as repeating subjects\n\n    if (subject[0] === '[') this._subject = ']';\n    return this._encodeIriOrBlankNode(subject);\n  },\n  // ### `_encodePredicate` represents a predicate\n  _encodePredicate: function _encodePredicate(predicate) {\n    if (predicate[0] === '\"') throw new Error('A literal as predicate is not allowed: ' + predicate);\n    return predicate === RDF_TYPE ? 'a' : this._encodeIriOrBlankNode(predicate);\n  },\n  // ### `_encodeObject` represents an object\n  _encodeObject: function _encodeObject(object) {\n    // Represent an IRI or blank node\n    if (object[0] !== '\"') return this._encodeIriOrBlankNode(object); // Represent a literal\n\n    var match = N3LiteralMatcher.exec(object);\n    if (!match) throw new Error('Invalid literal: ' + object);\n    return this._encodeLiteral(match[1], match[2], match[3]);\n  },\n  // ### `_blockedWrite` replaces `_write` after the writer has been closed\n  _blockedWrite: function _blockedWrite() {\n    throw new Error('Cannot write because the writer has been closed.');\n  },\n  // ### `addTriple` adds the triple to the output stream\n  addTriple: function addTriple(subject, predicate, object, graph, done) {\n    // The triple was given as a triple object, so shift parameters\n    if (object === undefined) this._writeTriple(subject.subject, subject.predicate, subject.object, subject.graph || '', predicate); // The optional `graph` parameter was not provided\n    else if (typeof graph !== 'string') this._writeTriple(subject, predicate, object, '', graph); // The `graph` parameter was provided\n      else this._writeTriple(subject, predicate, object, graph, done);\n  },\n  // ### `addTriples` adds the triples to the output stream\n  addTriples: function addTriples(triples) {\n    for (var i = 0; i < triples.length; i++) {\n      this.addTriple(triples[i]);\n    }\n  },\n  // ### `addPrefix` adds the prefix to the output stream\n  addPrefix: function addPrefix(prefix, iri, done) {\n    var prefixes = {};\n    prefixes[prefix] = iri;\n    this.addPrefixes(prefixes, done);\n  },\n  // ### `addPrefixes` adds the prefixes to the output stream\n  addPrefixes: function addPrefixes(prefixes, done) {\n    // Add all useful prefixes\n    var prefixIRIs = this._prefixIRIs,\n        hasPrefixes = false;\n\n    for (var prefix in prefixes) {\n      // Verify whether the prefix can be used and does not exist yet\n      var iri = prefixes[prefix];\n\n      if (/[#\\/]$/.test(iri) && prefixIRIs[iri] !== (prefix += ':')) {\n        hasPrefixes = true;\n        prefixIRIs[iri] = prefix; // Finish a possible pending triple\n\n        if (this._subject !== null) {\n          this._write(this._graph ? '\\n}\\n' : '.\\n');\n\n          this._subject = null, this._graph = '';\n        } // Write prefix\n\n\n        this._write('@prefix ' + prefix + ' <' + iri + '>.\\n');\n      }\n    } // Recreate the prefix matcher\n\n\n    if (hasPrefixes) {\n      var IRIlist = '',\n          prefixList = '';\n\n      for (var prefixIRI in prefixIRIs) {\n        IRIlist += IRIlist ? '|' + prefixIRI : prefixIRI;\n        prefixList += (prefixList ? '|' : '') + prefixIRIs[prefixIRI];\n      }\n\n      IRIlist = IRIlist.replace(/[\\]\\/\\(\\)\\*\\+\\?\\.\\\\\\$]/g, '\\\\$&');\n      this._prefixRegex = new RegExp('^(?:' + prefixList + ')[^\\/]*$|' + '^(' + IRIlist + ')([a-zA-Z][\\\\-_a-zA-Z0-9]*)$');\n    } // End a prefix block with a newline\n\n\n    this._write(hasPrefixes ? '\\n' : '', done);\n  },\n  // ### `blank` creates a blank node with the given content\n  blank: function blank(predicate, object) {\n    var children = predicate,\n        child,\n        length; // Empty blank node\n\n    if (predicate === undefined) children = []; // Blank node passed as blank(\"predicate\", \"object\")\n    else if (typeof predicate === 'string') children = [{\n        predicate: predicate,\n        object: object\n      }]; // Blank node passed as blank({ predicate: predicate, object: object })\n      else if (!('length' in predicate)) children = [predicate];\n\n    switch (length = children.length) {\n      // Generate an empty blank node\n      case 0:\n        return '[]';\n      // Generate a non-nested one-triple blank node\n\n      case 1:\n        child = children[0];\n        if (child.object[0] !== '[') return '[ ' + this._encodePredicate(child.predicate) + ' ' + this._encodeObject(child.object) + ' ]';\n      // Generate a multi-triple or nested blank node\n\n      default:\n        var contents = '['; // Write all triples in order\n\n        for (var i = 0; i < length; i++) {\n          child = children[i]; // Write only the object is the predicate is the same as the previous\n\n          if (child.predicate === predicate) contents += ', ' + this._encodeObject(child.object); // Otherwise, write the predicate and the object\n          else {\n              contents += (i ? ';\\n  ' : '\\n  ') + this._encodePredicate(child.predicate) + ' ' + this._encodeObject(child.object);\n              predicate = child.predicate;\n            }\n        }\n\n        return contents + '\\n]';\n    }\n  },\n  // ### `list` creates a list node with the given content\n  list: function list(elements) {\n    var length = elements && elements.length || 0,\n        contents = new Array(length);\n\n    for (var i = 0; i < length; i++) {\n      contents[i] = this._encodeObject(elements[i]);\n    }\n\n    return '(' + contents.join(' ') + ')';\n  },\n  // ### `_prefixRegex` matches a prefixed name or IRI that begins with one of the added prefixes\n  _prefixRegex: /$0^/,\n  // ### `end` signals the end of the output stream\n  end: function end(done) {\n    // Finish a possible pending triple\n    if (this._subject !== null) {\n      this._write(this._graph ? '\\n}\\n' : '.\\n');\n\n      this._subject = null;\n    } // Disallow further writing\n\n\n    this._write = this._blockedWrite; // Try to end the underlying stream, ensuring done is called exactly one time\n\n    var singleDone = done && function (error, result) {\n      singleDone = null, done(error, result);\n    };\n\n    if (this._endStream) {\n      try {\n        return this._outputStream.end(singleDone);\n      } catch (error) {\n        /* error closing stream */\n      }\n    }\n\n    singleDone && singleDone();\n  }\n}; // Replaces a character by its escaped version\n\nfunction characterReplacer(character) {\n  // Replace a single character by its escaped version\n  var result = escapeReplacements[character];\n\n  if (result === undefined) {\n    // Replace a single character with its 4-bit unicode escape sequence\n    if (character.length === 1) {\n      result = character.charCodeAt(0).toString(16);\n      result = \"\\\\u0000\".substr(0, 6 - result.length) + result;\n    } // Replace a surrogate pair with its 8-bit unicode escape sequence\n    else {\n        result = ((character.charCodeAt(0) - 0xD800) * 0x400 + character.charCodeAt(1) + 0x2400).toString(16);\n        result = \"\\\\U00000000\".substr(0, 10 - result.length) + result;\n      }\n  }\n\n  return result;\n} // ## Exports\n// Export the `N3Writer` class as a whole.\n\n\nmodule.exports = N3Writer;","map":null,"metadata":{},"sourceType":"script"}