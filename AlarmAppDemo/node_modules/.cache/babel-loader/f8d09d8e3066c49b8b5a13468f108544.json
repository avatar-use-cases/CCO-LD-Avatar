{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\jason\\\\Documents\\\\APG\\\\Solid\\\\generatorTest\\\\wakeup-react\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _slicedToArray from \"C:\\\\Users\\\\jason\\\\Documents\\\\APG\\\\Solid\\\\generatorTest\\\\wakeup-react\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\jason\\\\Documents\\\\APG\\\\Solid\\\\generatorTest\\\\wakeup-react\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"C:\\\\Users\\\\jason\\\\Documents\\\\APG\\\\Solid\\\\generatorTest\\\\wakeup-react\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"C:\\\\Users\\\\jason\\\\Documents\\\\APG\\\\Solid\\\\generatorTest\\\\wakeup-react\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _toConsumableArray from \"C:\\\\Users\\\\jason\\\\Documents\\\\APG\\\\Solid\\\\generatorTest\\\\wakeup-react\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"C:\\\\Users\\\\jason\\\\Documents\\\\APG\\\\Solid\\\\generatorTest\\\\wakeup-react\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\jason\\\\Documents\\\\APG\\\\Solid\\\\generatorTest\\\\wakeup-react\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\jason\\\\Documents\\\\APG\\\\Solid\\\\generatorTest\\\\wakeup-react\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\jason\\\\Documents\\\\APG\\\\Solid\\\\generatorTest\\\\wakeup-react\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\jason\\\\Documents\\\\APG\\\\Solid\\\\generatorTest\\\\wakeup-react\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _asyncIterator from \"C:\\\\Users\\\\jason\\\\Documents\\\\APG\\\\Solid\\\\generatorTest\\\\wakeup-react\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncIterator\";\nvar _jsxFileName = \"C:\\\\Users\\\\jason\\\\Documents\\\\APG\\\\Solid\\\\generatorTest\\\\wakeup-react\\\\src\\\\containers\\\\Profile\\\\profile.container.js\";\nimport React, { Component } from 'react';\nimport { namedNode } from '@rdfjs/data-model';\nimport { withWebId } from '@inrupt/solid-react-components';\nimport { withToastManager } from 'react-toast-notifications';\nimport data from '@solid/query-ldflex';\nimport ProfileShape from \"../../contexts/profile-shape.json\";\nimport { entries } from \"../../utils\";\nimport ProfileComponent from \"./profile.component\";\nvar defaulProfilePhoto = '/img/icon/empty-profile.svg';\n/**\n * We are using ldflex to fetch profile data from a solid pod.\n * ldflex libary is using json-LD for this reason you will see async calls\n * when we want to get a field value, why ? becuase they are expanded the data\n * this means the result will have a better format to read on Javascript.\n * for more information please go to: https://github.com/solid/query-ldflex\n */\n\nexport var Profile =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(Profile, _Component);\n\n  function Profile(props) {\n    var _this;\n\n    _classCallCheck(this, Profile);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Profile).call(this, props));\n\n    _this.changeFormMode = function () {\n      _this.setState({\n        formMode: !_this.state.formMode,\n        updatedFields: {}\n      });\n    };\n\n    _this.setDefaultData = function () {\n      _this.setState({\n        formFields: _toConsumableArray(_this.state.formFields)\n      });\n    };\n\n    _this.onCancel = function () {\n      _this.changeFormMode();\n\n      _this.setDefaultData();\n    };\n\n    _this.isFormValid = function (updatedFields) {\n      var profile = ProfileShape.profile; // Gets all of the required fields from the profile shape\n\n      var requiredFields = profile.filter(function (field) {\n        return field.required;\n      }).map(function (field) {\n        return field.property;\n      }); // Checks  if the required fields in the form are not empty\n\n      return Object.keys(updatedFields).reduce(function (a, z) {\n        return [].concat(_toConsumableArray(a), [updatedFields[z]]);\n      }, []).reduce(function (a, z) {\n        return a === true && requiredFields.includes(z.property) ? z.value !== '' : a;\n      }, true);\n    };\n\n    _this.onInputChange = function (e) {\n      var input = e.target,\n          dataset = e.target.dataset;\n      var name = input.name;\n      var value = input.value;\n      var key = input.id;\n      var action = 'update';\n\n      if (value === '') {\n        action = _this.state.formFields.find(function (field) {\n          return field.property === name && field.value !== '';\n        }) ? 'delete' : action;\n      }\n\n      _this.setState({\n        updatedFields: _objectSpread({}, _this.state.updatedFields, _defineProperty({}, name, {\n          value: value,\n          action: action,\n          property: name,\n          nodeParentUri: dataset.nodeparenturi || null,\n          nodeBlank: dataset.nodeblank || null,\n          label: dataset.label,\n          icon: dataset.icon,\n          key: key\n        }))\n      });\n    };\n\n    _this.onSubmit =\n    /*#__PURE__*/\n    function () {\n      var _ref = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(e, successMessage, nameRequiredText) {\n        var node, newFields, updatedFields, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, _value2, _value3, key, field, updatedFormField;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                e.preventDefault();\n                newFields = [];\n                updatedFields = _this.state.updatedFields;\n\n                if (_this.isFormValid(updatedFields)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                throw new Error(nameRequiredText);\n\n              case 6:\n                _this.setState({\n                  isLoading: true\n                });\n                /*\n                 * Solid server has an issue on concurrent updates,\n                 * so to fix this we have to await one change, and only when it is done,\n                 * fire the next field update.\n                 * more info about the issue: https://github.com/solid/node-solid-server/issues/1106\n                 */\n\n\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _context.prev = 9;\n                _iterator = _asyncIterator(entries(_this.state.updatedFields));\n\n              case 11:\n                _context.next = 13;\n                return _iterator.next();\n\n              case 13:\n                _step = _context.sent;\n                _iteratorNormalCompletion = _step.done;\n                _context.next = 17;\n                return _step.value;\n\n              case 17:\n                _value = _context.sent;\n\n                if (_iteratorNormalCompletion) {\n                  _context.next = 33;\n                  break;\n                }\n\n                _value2 = _value, _value3 = _slicedToArray(_value2, 2), key = _value3[0], field = _value3[1];\n                node = data.user[key];\n\n                if (field.nodeBlank) {\n                  node = data[field.nodeParentUri][field.nodeBlank];\n                }\n\n                if (!(field.action === 'update')) {\n                  _context.next = 27;\n                  break;\n                }\n\n                _context.next = 25;\n                return node.set(field.value);\n\n              case 25:\n                _context.next = 29;\n                break;\n\n              case 27:\n                _context.next = 29;\n                return node.delete();\n\n              case 29:\n                newFields = [].concat(_toConsumableArray(newFields), [_objectSpread({}, field)]);\n\n              case 30:\n                _iteratorNormalCompletion = true;\n                _context.next = 11;\n                break;\n\n              case 33:\n                _context.next = 39;\n                break;\n\n              case 35:\n                _context.prev = 35;\n                _context.t0 = _context[\"catch\"](9);\n                _didIteratorError = true;\n                _iteratorError = _context.t0;\n\n              case 39:\n                _context.prev = 39;\n                _context.prev = 40;\n\n                if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                  _context.next = 44;\n                  break;\n                }\n\n                _context.next = 44;\n                return _iterator.return();\n\n              case 44:\n                _context.prev = 44;\n\n                if (!_didIteratorError) {\n                  _context.next = 47;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 47:\n                return _context.finish(44);\n\n              case 48:\n                return _context.finish(39);\n\n              case 49:\n                /*\n                 * We need to update formFields with new fields states\n                 * we are using these states to know if field need to delete, update or create\n                 * on POD and know if fields were updated by the user on the profile.\n                 */\n                updatedFormField = _this.state.formFields.map(function (field) {\n                  return newFields.find(function (f) {\n                    return f.label === field.label;\n                  }) || field;\n                });\n\n                _this.setState({\n                  formFields: updatedFormField,\n                  updatedFields: {},\n                  formMode: true,\n                  isLoading: false\n                });\n\n                _this.props.toastManager.add(['', successMessage], {\n                  appearance: 'success'\n                });\n\n                _context.next = 58;\n                break;\n\n              case 54:\n                _context.prev = 54;\n                _context.t1 = _context[\"catch\"](0);\n\n                _this.props.toastManager.add(['Error', _context.t1.message], {\n                  appearance: 'error'\n                });\n\n                _this.setState({\n                  isLoading: false\n                });\n\n              case 58:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 54], [9, 35, 39, 49], [40,, 44, 48]]);\n      }));\n\n      return function (_x, _x2, _x3) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    _this.fetchPhoto =\n    /*#__PURE__*/\n    _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee2() {\n      var user, image, hasImage;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n              // We are fetching profile card document\n              user = data[_this.props.webId]; // We access to document node using a node name\n\n              _context2.next = 4;\n              return user.image;\n\n            case 4:\n              image = _context2.sent;\n              hasImage = true; // If image is not present on card we try with hasPhoto\n\n              if (image) {\n                _context2.next = 11;\n                break;\n              }\n\n              _context2.next = 9;\n              return user.vcard_hasPhoto;\n\n            case 9:\n              image = _context2.sent;\n              hasImage = false;\n\n            case 11:\n              _this.setState({\n                photo: image && image.value || defaulProfilePhoto,\n                hasImage: hasImage\n              });\n\n              _context2.next = 17;\n              break;\n\n            case 14:\n              _context2.prev = 14;\n              _context2.t0 = _context2[\"catch\"](0);\n\n              _this.props.toastManager.add(['Error', _context2.t0.message], {\n                appearance: 'error'\n              });\n\n            case 17:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this, [[0, 14]]);\n    }));\n\n    _this.updatePhoto =\n    /*#__PURE__*/\n    function () {\n      var _ref3 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(uri, message) {\n        var user;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                user = data.user;\n\n                if (!_this.state.hasImage) {\n                  _context3.next = 7;\n                  break;\n                }\n\n                _context3.next = 5;\n                return user.image.set(uri);\n\n              case 5:\n                _context3.next = 9;\n                break;\n\n              case 7:\n                _context3.next = 9;\n                return user.image.add(uri);\n\n              case 9:\n                _this.props.toastManager.add(['', message], {\n                  appearance: 'success'\n                });\n\n                _context3.next = 15;\n                break;\n\n              case 12:\n                _context3.prev = 12;\n                _context3.t0 = _context3[\"catch\"](0);\n\n                _this.props.toastManager.add(['Error', _context3.t0.message], {\n                  appearance: 'error'\n                });\n\n              case 15:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 12]]);\n      }));\n\n      return function (_x4, _x5) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n\n    _this.fetchProfile =\n    /*#__PURE__*/\n    _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee5() {\n      var profile, user, formFields;\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.prev = 0;\n\n              /**\n               * We fetch profile shape from context/profile-shape.json\n               * profile-shape.json has all the fields that we want to print\n               * we are using icons on each field to mapping with the UI design.\n               */\n              profile = ProfileShape.profile; // We are fetching profile card document\n\n              user = data[_this.props.webId];\n              /**\n               * We run each shapes on profile-shape.json and access to each\n               * field value, in case that node field value point to another\n               * node blank we acces using multidimensional array if not we\n               * access by a basic array.\n               */\n\n              _context5.next = 5;\n              return Promise.all(profile.map(\n              /*#__PURE__*/\n              function () {\n                var _ref5 = _asyncToGenerator(\n                /*#__PURE__*/\n                _regeneratorRuntime.mark(function _callee4(field) {\n                  return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                    while (1) {\n                      switch (_context4.prev = _context4.next) {\n                        case 0:\n                          _context4.t0 = _objectSpread;\n                          _context4.t1 = {};\n                          _context4.t2 = field;\n                          _context4.next = 5;\n                          return _this.getNodeValue(user, field);\n\n                        case 5:\n                          _context4.t3 = _context4.sent;\n                          return _context4.abrupt(\"return\", (0, _context4.t0)(_context4.t1, _context4.t2, _context4.t3));\n\n                        case 7:\n                        case \"end\":\n                          return _context4.stop();\n                      }\n                    }\n                  }, _callee4, this);\n                }));\n\n                return function (_x6) {\n                  return _ref5.apply(this, arguments);\n                };\n              }()));\n\n            case 5:\n              formFields = _context5.sent;\n\n              _this.setState({\n                profile: profile,\n                formFields: formFields\n              });\n\n              _context5.next = 12;\n              break;\n\n            case 9:\n              _context5.prev = 9;\n              _context5.t0 = _context5[\"catch\"](0);\n\n              _this.props.toastManager.add(['Error', _context5.t0.message], {\n                appearance: 'error'\n              });\n\n            case 12:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5, this, [[0, 9]]);\n    }));\n\n    _this.createNewLinkNode =\n    /*#__PURE__*/\n    function () {\n      var _ref6 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee6(property) {\n        var id;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                id = \"#id\".concat(Date.parse(new Date()));\n                _context6.next = 3;\n                return data.user[property].add(namedNode(id));\n\n              case 3:\n                return _context6.abrupt(\"return\", \"\".concat(_this.props.webId.split('#')[0]).concat(id));\n\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      return function (_x7) {\n        return _ref6.apply(this, arguments);\n      };\n    }();\n\n    _this.getNodeValue =\n    /*#__PURE__*/\n    function () {\n      var _ref7 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee7(user, field) {\n        var node, nodeParentUri, parentNode;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!field.nodeBlank) {\n                  _context7.next = 15;\n                  break;\n                }\n\n                _context7.next = 3;\n                return user[field.property];\n\n              case 3:\n                parentNode = _context7.sent;\n                _context7.t0 = parentNode && parentNode.value;\n\n                if (_context7.t0) {\n                  _context7.next = 9;\n                  break;\n                }\n\n                _context7.next = 8;\n                return _this.createNewLinkNode(field.property);\n\n              case 8:\n                _context7.t0 = _context7.sent;\n\n              case 9:\n                nodeParentUri = _context7.t0;\n                _context7.next = 12;\n                return user[field.property][field.nodeBlank];\n\n              case 12:\n                node = _context7.sent;\n                _context7.next = 18;\n                break;\n\n              case 15:\n                _context7.next = 17;\n                return user[field.property];\n\n              case 17:\n                node = _context7.sent;\n\n              case 18:\n                return _context7.abrupt(\"return\", {\n                  action: 'update',\n                  value: node && node.value || '',\n                  nodeParentUri: nodeParentUri\n                });\n\n              case 19:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      return function (_x8, _x9) {\n        return _ref7.apply(this, arguments);\n      };\n    }();\n\n    _this.state = {\n      formMode: true,\n      isLoading: false,\n      photo: defaulProfilePhoto,\n      formFields: [],\n      newLinkNodes: [],\n      updatedFields: {}\n    };\n    return _this;\n  }\n\n  _createClass(Profile, [{\n    key: \"componentDidMount\",\n    value: function () {\n      var _componentDidMount = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee8() {\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                this.setState({\n                  isLoading: true\n                });\n                _context8.next = 3;\n                return this.fetchPhoto();\n\n              case 3:\n                _context8.next = 5;\n                return this.fetchProfile();\n\n              case 5:\n                this.setState({\n                  isLoading: false\n                });\n\n              case 6:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function componentDidMount() {\n        return _componentDidMount.apply(this, arguments);\n      }\n\n      return componentDidMount;\n    }()\n  }, {\n    key: \"render\",\n    value: function render() {\n      return React.createElement(ProfileComponent, {\n        webId: this.props.webId,\n        formFields: this.state.formFields,\n        updatedFields: this.state.updatedFields,\n        formMode: this.state.formMode,\n        onInputChange: this.onInputChange,\n        onSubmit: this.onSubmit,\n        onCancel: this.onCancel,\n        updatePhoto: this.updatePhoto,\n        photo: this.state.photo,\n        changeFormMode: this.changeFormMode,\n        isLoading: this.state.isLoading,\n        toastManager: this.props.toastManager,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 317\n        },\n        __self: this\n      });\n    }\n  }]);\n\n  return Profile;\n}(Component);\nexport default withWebId(withToastManager(Profile));","map":{"version":3,"sources":["C:\\Users\\jason\\Documents\\APG\\Solid\\generatorTest\\wakeup-react\\src\\containers\\Profile\\profile.container.js"],"names":["React","Component","namedNode","withWebId","withToastManager","data","ProfileShape","entries","ProfileComponent","defaulProfilePhoto","Profile","props","changeFormMode","setState","formMode","state","updatedFields","setDefaultData","formFields","onCancel","isFormValid","profile","requiredFields","filter","field","required","map","property","Object","keys","reduce","a","z","includes","value","onInputChange","e","input","target","dataset","name","key","id","action","find","nodeParentUri","nodeparenturi","nodeBlank","nodeblank","label","icon","onSubmit","successMessage","nameRequiredText","preventDefault","newFields","Error","isLoading","node","user","set","delete","updatedFormField","f","toastManager","add","appearance","message","fetchPhoto","webId","image","hasImage","vcard_hasPhoto","photo","updatePhoto","uri","fetchProfile","Promise","all","getNodeValue","createNewLinkNode","Date","parse","split","parentNode","newLinkNodes"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport { namedNode } from '@rdfjs/data-model';\nimport { withWebId } from '@inrupt/solid-react-components';\nimport { withToastManager } from 'react-toast-notifications';\nimport data from '@solid/query-ldflex';\nimport ProfileShape from '@contexts/profile-shape.json';\nimport { entries } from '@utils';\nimport ProfileComponent from './profile.component';\n\nconst defaulProfilePhoto = '/img/icon/empty-profile.svg';\n\n/**\n * We are using ldflex to fetch profile data from a solid pod.\n * ldflex libary is using json-LD for this reason you will see async calls\n * when we want to get a field value, why ? becuase they are expanded the data\n * this means the result will have a better format to read on Javascript.\n * for more information please go to: https://github.com/solid/query-ldflex\n */\n\nexport class Profile extends Component {\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            formMode: true,\n            isLoading: false,\n            photo: defaulProfilePhoto,\n            formFields: [],\n            newLinkNodes: [],\n            updatedFields: {},\n        };\n    }\n    async componentDidMount() {\n        this.setState({ isLoading: true });\n        await this.fetchPhoto();\n        await this.fetchProfile();\n        this.setState({ isLoading: false });\n    }\n\n    changeFormMode = () => {\n        this.setState({ formMode: !this.state.formMode, updatedFields: {} });\n    };\n    setDefaultData = () => {\n        this.setState({ formFields: [...this.state.formFields] });\n    };\n    onCancel = () => {\n        this.changeFormMode();\n        this.setDefaultData();\n    };\n\n  /**\n   * Checks if the form is valid to be submitted by comparing and mapping the ProfileShape fields with the form inputs\n   * @param updatedFields\n   * @returns {*|boolean}\n   */\n  isFormValid = updatedFields => {\n        const { profile } = ProfileShape;\n        // Gets all of the required fields from the profile shape\n        const requiredFields = profile\n            .filter(field => field.required)\n            .map(field => field.property);\n        // Checks  if the required fields in the form are not empty\n        return Object.keys(updatedFields)\n            .reduce((a, z) => [...a, updatedFields[z]], [])\n            .reduce(\n                (a, z) =>\n                    a === true && requiredFields.includes(z.property)\n                        ? z.value !== ''\n                        : a,\n                true\n            );\n    };\n\n    /**\n     * All input changes values will add it into the updatedFields state.\n     * This object will be run like an iterator, later on. We are using a flag to know\n     * when to update or delete fields into PODS.\n     */\n    onInputChange = (e: Event) => {\n        const {\n            target: input,\n            target: { dataset },\n        } = e;\n        const name = input.name;\n        const value = input.value;\n        const key = input.id;\n        let action = 'update';\n\n        if (value === '') {\n            action = this.state.formFields.find(\n                field => field.property === name && field.value !== ''\n            )\n                ? 'delete'\n                : action;\n        }\n\n        this.setState({\n            updatedFields: {\n                ...this.state.updatedFields,\n                [name]: {\n                    value,\n                    action,\n                    property: name,\n                    nodeParentUri: dataset.nodeparenturi || null,\n                    nodeBlank: dataset.nodeblank || null,\n                    label: dataset.label,\n                    icon: dataset.icon,\n                    key,\n                },\n            },\n        });\n    };\n    /**\n     * onSubmit will send all the updated fields to POD\n     * fields that was not updated will be not send it.\n     */\n    onSubmit = async (\n        e: Event,\n        successMessage: String,\n        nameRequiredText: String\n    ) => {\n        try {\n            e.preventDefault();\n            let node;\n            let newFields = [];\n            const { updatedFields } = this.state;\n            if (!this.isFormValid(updatedFields)) throw new Error(nameRequiredText);\n\n            this.setState({ isLoading: true });\n            /*\n             * Solid server has an issue on concurrent updates,\n             * so to fix this we have to await one change, and only when it is done,\n             * fire the next field update.\n             * more info about the issue: https://github.com/solid/node-solid-server/issues/1106\n             */\n\n            for await (const [key, field] of entries(\n                this.state.updatedFields\n            )) {\n                node = data.user[key];\n\n                if (field.nodeBlank) {\n                    node = data[field.nodeParentUri][field.nodeBlank];\n                }\n\n                if (field.action === 'update') {\n                    await node.set(field.value);\n                } else {\n                    await node.delete();\n                }\n\n                newFields = [\n                    ...newFields,\n                    {\n                        ...field,\n                    },\n                ];\n            }\n\n            /*\n             * We need to update formFields with new fields states\n             * we are using these states to know if field need to delete, update or create\n             * on POD and know if fields were updated by the user on the profile.\n             */\n            const updatedFormField = this.state.formFields.map(\n                field => newFields.find(f => f.label === field.label) || field\n            );\n\n            this.setState({\n                formFields: updatedFormField,\n                updatedFields: {},\n                formMode: true,\n                isLoading: false,\n            });\n\n            this.props.toastManager.add(['', successMessage], {\n                appearance: 'success',\n            });\n        } catch (error) {\n            this.props.toastManager.add(['Error', error.message], {\n                appearance: 'error',\n            });\n            this.setState({ isLoading: false });\n        }\n    };\n    /**\n     * Fetch profile photo from card\n     */\n    fetchPhoto = async () => {\n        try {\n            // We are fetching profile card document\n            const user = data[this.props.webId];\n            // We access to document node using a node name\n            let image = await user.image;\n            let hasImage = true;\n            // If image is not present on card we try with hasPhoto\n            if (!image) {\n                /**\n                 * hasPhoto is a new context that ldflex doesn't having\n                 * we need to add it manually.\n                 * if you want to know more about context please go to:\n                 * https://github.com/digitalbazaar/jsonld.js\n                 */\n                image = await user.vcard_hasPhoto;\n\n                hasImage = false;\n            }\n\n            this.setState({\n                photo: (image && image.value) || defaulProfilePhoto,\n                hasImage,\n            });\n        } catch (error) {\n            this.props.toastManager.add(['Error', error.message], {\n                appearance: 'error',\n            });\n        }\n    };\n    /**\n     * updatedPhoto will update the photo url on vcard file\n     * this function will check if user has image or hasPhoto node if not\n     * will just update it, the idea is use image instead of hasPhoto\n     * @params{String} uri photo url\n     */\n    updatePhoto = async (uri: String, message: String) => {\n        try {\n            const { user } = data;\n            this.state.hasImage\n                ? await user.image.set(uri)\n                : await user.image.add(uri);\n\n            this.props.toastManager.add(['', message], {\n                appearance: 'success',\n            });\n        } catch (error) {\n            this.props.toastManager.add(['Error', error.message], {\n                appearance: 'error',\n            });\n        }\n    };\n    /**\n     * Fetch Profile Shape data\n     */\n    fetchProfile = async () => {\n        try {\n            /**\n             * We fetch profile shape from context/profile-shape.json\n             * profile-shape.json has all the fields that we want to print\n             * we are using icons on each field to mapping with the UI design.\n             */\n            const { profile } = ProfileShape;\n            // We are fetching profile card document\n            const user = data[this.props.webId];\n\n            /**\n             * We run each shapes on profile-shape.json and access to each\n             * field value, in case that node field value point to another\n             * node blank we acces using multidimensional array if not we\n             * access by a basic array.\n             */\n            const formFields = await Promise.all(\n                profile.map(async field => {\n                    return {\n                        ...field,\n                        ...(await this.getNodeValue(user, field)),\n                    };\n                })\n            );\n            this.setState({ profile, formFields });\n        } catch (error) {\n            this.props.toastManager.add(['Error', error.message], {\n                appearance: 'error',\n            });\n        }\n    };\n    /**\n     * Create a new node link on vcard document.\n     * @params{String} property\n     * Property param will be the name of node\n     */\n    createNewLinkNode = async (property: String) => {\n        const id = `#id${Date.parse(new Date())}`;\n        await data.user[property].add(namedNode(id));\n        // @TODO: add from ldflex should return this value instead of create by our self\n        return `${this.props.webId.split('#')[0]}${id}`;\n    };\n    /**\n     * getNodeValue will return node value and uri in case that node points to nodeBlank\n     * nodeParentUri is a workaround to fix blank node update fields on ldflex\n     * @params{Object} user\n     * @params{Object} field\n     */\n    getNodeValue = async (user: Object, field: Object) => {\n        let node;\n        let nodeParentUri;\n        // If node is a pointer to another node will get the value\n        if (field.nodeBlank) {\n            let parentNode = await user[field.property];\n            // If the node link doesn't exist will create a new one.\n            nodeParentUri =\n                (parentNode && parentNode.value) ||\n                (await this.createNewLinkNode(field.property));\n\n            node = await user[field.property][field.nodeBlank];\n        } else {\n            node = await user[field.property];\n        }\n\n        return {\n            action: 'update',\n            value: (node && node.value) || '',\n            nodeParentUri,\n        };\n    };\n    render() {\n        return (\n            <ProfileComponent\n                webId={this.props.webId}\n                formFields={this.state.formFields}\n                updatedFields={this.state.updatedFields}\n                formMode={this.state.formMode}\n                onInputChange={this.onInputChange}\n                onSubmit={this.onSubmit}\n                onCancel={this.onCancel}\n                updatePhoto={this.updatePhoto}\n                photo={this.state.photo}\n                changeFormMode={this.changeFormMode}\n                isLoading={this.state.isLoading}\n                toastManager={this.props.toastManager}\n            />\n        );\n    }\n}\n\nexport default withWebId(withToastManager(Profile));\n"]},"metadata":{},"sourceType":"module"}