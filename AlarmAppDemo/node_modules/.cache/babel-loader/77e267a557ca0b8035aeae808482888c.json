{"ast":null,"code":"var _classCallCheck = require(\"C:\\\\Users\\\\jason\\\\Documents\\\\APG\\\\Solid\\\\BIGSOLID\\\\CCO-LD-Avatar\\\\AlarmAppDemo\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\jason\\\\Documents\\\\APG\\\\Solid\\\\BIGSOLID\\\\CCO-LD-Avatar\\\\AlarmAppDemo\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\n/**\n * Local dependencies\n */\nvar CryptoKey = require('./keys/CryptoKey');\n\nvar CryptoKeyPair = require('./keys/CryptoKeyPair');\n\nvar JsonWebKey = require('./keys/JsonWebKey');\n\nvar recognizedKeyUsages = require('./keys/recognizedKeyUsages');\n\nvar supportedAlgorithms = require('./algorithms');\n\nvar _require = require('./errors'),\n    InvalidAccessError = _require.InvalidAccessError,\n    NotSupportedError = _require.NotSupportedError;\n/**\n * SubtleCrypto\n */\n\n\nvar SubtleCrypto =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function SubtleCrypto() {\n    _classCallCheck(this, SubtleCrypto);\n  }\n\n  _createClass(SubtleCrypto, [{\n    key: \"encrypt\",\n\n    /**\n     * encrypt\n     *\n     * @description\n     *\n     * @param {AlgorithmIdentifier} algorithm\n     * @param {CryptoKey} key\n     * @param {BufferSource} data\n     *\n     * @returns {Promise}\n     */\n    value: function encrypt(algorithm, key, data) {\n      return new Promise();\n    }\n    /**\n     * decrypt\n     *\n     * @description\n     *\n     * @param {AlgorithmIdentifier} algorithm\n     * @param {CryptoKey} key\n     * @param {BufferSource} data\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"decrypt\",\n    value: function decrypt(algorithm, key, data) {\n      return new Promise();\n    }\n    /**\n     * sign\n     *\n     * @description\n     *\n     * @param {AlgorithmIdentifier} algorithm\n     * @param {CryptoKey} key\n     * @param {BufferSource} data\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"sign\",\n    value: function sign(algorithm, key, data) {\n      data = data.slice();\n      var normalizedAlgorithm = supportedAlgorithms.normalize('sign', algorithm);\n\n      if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(normalizedAlgorithm);\n      }\n\n      return new Promise(function (resolve, reject) {\n        if (normalizedAlgorithm.name !== key.algorithm.name) {\n          throw new InvalidAccessError('Algorithm does not match key');\n        }\n\n        if (!key.usages.includes('sign')) {\n          throw new InvalidAccessError('Key usages must include \"sign\"');\n        }\n\n        var result = normalizedAlgorithm.sign(key, data);\n        resolve(result);\n      });\n    }\n    /**\n     * verify\n     *\n     * @description\n     *\n     * @param {AlgorithmIdentifier} algorithm\n     * @param {CryptoKey} key\n     * @param {BufferSource} signature\n     * @param {BufferSource} data\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"verify\",\n    value: function verify(alg, key, signature, data) {\n      signature = signature.slice();\n      var normalizedAlgorithm = supportedAlgorithms.normalize('verify', alg);\n\n      if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(normalizedAlgorithm);\n      }\n\n      data = data.slice();\n      return new Promise(function (resolve, reject) {\n        if (normalizedAlgorithm.name !== key.algorithm.name) {\n          throw new InvalidAccessError('Algorithm does not match key');\n        }\n\n        if (!key.usages.includes('verify')) {\n          throw new InvalidAccessError('Key usages must include \"verify\"');\n        }\n\n        var result = normalizedAlgorithm.verify(key, signature, data);\n        resolve(result);\n      });\n    }\n    /**\n     * digest\n     *\n     * @description\n     *\n     * @param {AlgorithmIdentifier} algorithm\n     * @param {BufferSource} data\n     *\n     * @returns {Promise.<ArrayBuffer>}\n     */\n\n  }, {\n    key: \"digest\",\n    value: function digest(algorithm, data) {\n      data = data.slice();\n      var normalizedAlgorithm = supportedAlgorithms.normalize('digest', algorithm);\n\n      if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(normalizedAlgorithm);\n      }\n\n      return new Promise(function (resolve, reject) {\n        try {\n          var result = normalizedAlgorithm.digest(algorithm, data);\n          return resolve(result);\n        } catch (error) {\n          return reject(error);\n        }\n      });\n    }\n    /**\n     * generateKey\n     *\n     * @description\n     *\n     * @param {AlgorithmIdentifier} algorithm\n     * @param {Boolean} extractable\n     * @param {Array} keyUsages\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"generateKey\",\n    value: function generateKey(algorithm, extractable, keyUsages) {\n      var normalizedAlgorithm = supportedAlgorithms.normalize('generateKey', algorithm);\n\n      if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(normalizedAlgorithm);\n      }\n\n      return new Promise(function (resolve, reject) {\n        try {\n          var result = normalizedAlgorithm.generateKey(algorithm, extractable, keyUsages);\n\n          if (result instanceof CryptoKey) {\n            var type = result.type,\n                usages = result.usages;\n            var restricted = type === 'secret' || type === 'private';\n            var emptyUsages = !usages || usages.length === 0;\n\n            if (restricted && emptyUsages) {\n              throw new SyntaxError();\n            }\n          }\n\n          if (result instanceof CryptoKeyPair) {\n            var _usages = result.privateKey.usages;\n\n            if (!_usages || _usages.length === 0) {\n              throw new SyntaxError();\n            }\n          }\n\n          resolve(result);\n        } catch (error) {\n          return reject(error);\n        }\n      });\n    }\n    /**\n     * deriveKey\n     *\n     * @description\n     *\n     * @param {AlgorithmIdentifier} algorithm\n     * @param {CryptoKey} baseKey\n     * @param {AlgorithmIdentifier} derivedKeyType\n     * @param {Boolean} extractable\n     * @param {Array} keyUsages\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"deriveKey\",\n    value: function deriveKey(algorithm, baseKey, derivedKeyType, extractable, keyUsages) {\n      return new Promise();\n    }\n    /**\n     * deriveBits\n     *\n     * @description\n     *\n     * @param {AlgorithmIdentifier} algorithm\n     * @param {CryptoKey} baseKey\n     * @param {number} length\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"deriveBits\",\n    value: function deriveBits(algorithm, baseKey, length) {\n      return new Promise();\n    }\n    /**\n     * importKey\n     *\n     * @description\n     *\n     * @param {KeyFormat} format\n     * @param {BufferSource|JWK} keyData\n     * @param {AlgorithmIdentifier} algorithm\n     * @param {Boolean} extractable\n     * @param {Array} keyUsages\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"importKey\",\n    value: function importKey(format, keyData, algorithm, extractable, keyUsages) {\n      var normalizedAlgorithm = supportedAlgorithms.normalize('importKey', algorithm);\n\n      if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(normalizedAlgorithm);\n      }\n\n      return new Promise(function (resolve, reject) {\n        if (format === 'raw' || format === 'pkcs8' || format === 'spki') {\n          if (keyData instanceof JsonWebKey) {\n            throw new TypeError();\n          }\n\n          keyData = keyData.slice();\n        }\n\n        if (format === 'jwk') {\n          keyData = new JsonWebKey(keyData);\n\n          if (!(keyData instanceof JsonWebKey)) {\n            throw new TypeError('key is not a JSON Web Key');\n          }\n        }\n\n        try {\n          var result = normalizedAlgorithm.importKey(format, keyData, algorithm, extractable, keyUsages);\n\n          if (result.type === 'secret' || result.type === 'private') {\n            if (!result.usages || result.usages.length === 0) {\n              throw new SyntaxError();\n            }\n          }\n\n          result.extractable = extractable;\n          result.usages = recognizedKeyUsages.normalize(keyUsages);\n          resolve(result);\n        } catch (error) {\n          return reject(error);\n        }\n      });\n    }\n    /**\n     * exportKey\n     *\n     * @description\n     *\n     * @param {KeyFormat} format\n     * @param {CryptoKey} key\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"exportKey\",\n    value: function exportKey(format, key) {\n      return new Promise(function (resolve, reject) {\n        try {\n          var registeredAlgorithms = supportedAlgorithms['exportKey'];\n\n          if (!registeredAlgorithms[key.algorithm.name]) {\n            throw new NotSupportedError(key.algorithm.name);\n          }\n\n          if (key.extractable === false) {\n            throw new InvalidAccessError('Key is not extractable');\n          }\n\n          var result = key.algorithm.exportKey(format, key);\n          resolve(result);\n        } catch (error) {\n          return reject(error);\n        }\n      });\n    }\n    /**\n     * wrapKey\n     *\n     * @description\n     *\n     * @param {KeyFormat} format\n     * @param {CryptoKey} key\n     * @param {CryptoKey} wrappingKey\n     * @param {AlgorithmIdentifier} wrapAlgorithm\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"wrapKey\",\n    value: function wrapKey(format, key, wrappingKey, wrapAlgorithm) {\n      return new Promise();\n    }\n    /**\n     * unwrapKey\n     *\n     * @description\n     *\n     * @param {KeyFormat} format\n     * @param {BufferSource} wrappedKey\n     * @param {CryptoKey} unwrappingKey\n     * @param {AlgorithmIdentifier} unwrapAlgorithm\n     * @param {AlgorithmIdentifier} unwrappedKeyAlgorithm\n     * @param {Boolean} extractable\n     * @param {Array} keyUsages\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"unwrapKey\",\n    value: function unwrapKey(format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, exractable, keyUsages) {\n      return new Promise();\n    }\n  }]);\n\n  return SubtleCrypto;\n}();\n/**\n * Export\n */\n\n\nmodule.exports = SubtleCrypto;","map":null,"metadata":{},"sourceType":"script"}