{"ast":null,"code":"'use strict';\n/**\n * The superclass of all RDF Statement objects, that is\n * NamedNode, Literal, BlankNode, etc.\n * @class Node\n */\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar Node =\n/*#__PURE__*/\nfunction () {\n  function Node() {\n    _classCallCheck(this, Node);\n  }\n\n  _createClass(Node, [{\n    key: \"substitute\",\n    value: function substitute(bindings) {\n      console.log('@@@ node substitute' + this);\n      return this;\n    }\n  }, {\n    key: \"compareTerm\",\n    value: function compareTerm(other) {\n      if (this.classOrder < other.classOrder) {\n        return -1;\n      }\n\n      if (this.classOrder > other.classOrder) {\n        return +1;\n      }\n\n      if (this.value < other.value) {\n        return -1;\n      }\n\n      if (this.value > other.value) {\n        return +1;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (!other) {\n        return false;\n      }\n\n      return this.termType === other.termType && this.value === other.value;\n    }\n  }, {\n    key: \"hashString\",\n    value: function hashString() {\n      return this.toCanonical();\n    }\n  }, {\n    key: \"sameTerm\",\n    value: function sameTerm(other) {\n      return this.equals(other);\n    }\n  }, {\n    key: \"toCanonical\",\n    value: function toCanonical() {\n      return this.toNT();\n    }\n  }, {\n    key: \"toNT\",\n    value: function toNT() {\n      return this.toString();\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      throw new Error('Node.toString() is abstract - see the subclasses instead');\n    }\n  }]);\n\n  return Node;\n}();\n\nmodule.exports = Node;\n/**\n * Creates an RDF Node from a native javascript value.\n * RDF Nodes are returned unchanged, undefined returned as itself.\n * @method fromValue\n * @static\n * @param value {Node|Date|String|Number|Boolean|Undefined}\n * @return {Node|Collection}\n */\n\nNode.fromValue = function fromValue(value) {\n  var Collection = require('./collection');\n\n  var Literal = require('./literal');\n\n  var NamedNode = require('./named-node');\n\n  if (typeof value === 'undefined' || value === null) {\n    return value;\n  }\n\n  var isNode = value && value.termType;\n\n  if (isNode) {\n    // a Node subclass or a Collection\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    return new Collection(value);\n  }\n\n  return Literal.fromValue(value);\n};\n\nvar Namespace = require('./namespace');\n\nvar ns = {\n  xsd: Namespace('http://www.w3.org/2001/XMLSchema#')\n};\n\nNode.toJS = function toJS(term) {\n  if (term.elements) {\n    return term.elements.map(Node.toJS); // Array node (not standard RDFJS)\n  }\n\n  if (!term.datatype) return term; // Objects remain objects\n\n  if (term.datatype.sameTerm(ns.xsd('boolean'))) {\n    return term.value === '1';\n  }\n\n  if (term.datatype.sameTerm(ns.xsd('dateTime')) || term.datatype.sameTerm(ns.xsd('date'))) {\n    return new Date(term.value);\n  }\n\n  if (term.datatype.sameTerm(ns.xsd('integer')) || term.datatype.sameTerm(ns.xsd('float')) || term.datatype.sameTerm(ns.xsd('decimal'))) {\n    var z = Number(term.value);\n    return Number(term.value);\n  }\n\n  return term.value;\n};","map":null,"metadata":{},"sourceType":"script"}